.TH "stf::cam" 3 "Version 0.0.0" "stf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
stf::cam \- Namespace for camera-related functionality\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBfrustum\fP"
.br
.RI "Struct to represent a frustumed pyramid in R^3\&. "
.ti -1c
.RI "struct \fBscamera\fP"
.br
.RI "Struct to represent a simple camera -- one where the right vector is always in the plane normal to (0, 0, 1)\&. The look direction is represented by spherical coordinates with the eye as the origin\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > bool \fBequ\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs, T eps)"
.br
.RI "Compute whether the distance between \fClhs\fP and \fCrhs\fP is less than or equal to \fCeps\fP\&. "
.ti -1c
.RI "template<typename T > bool \fBneq\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs, T eps)"
.br
.RI "Compute whether the distance between \fClhs\fP and \fCrhs\fP is strictly greater than eps\&. "
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses constants<T>::tol as epsilon) "
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses constants<T>::tol as epsilon) "
.ti -1c
.RI "template<typename T > \fBscamera\fP< T > \fBlerp\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs, T const t)"
.br
.RI "Linearly interpolate scameras\&. "
.ti -1c
.RI "template<typename T > \fBscamera\fP< T > \fBlerpstep\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs, T const t)"
.br
.RI "Linearly interpolate scameras (clamped to the endpoint values) "
.ti -1c
.RI "template<typename T > \fBscamera\fP< T > \fBsmoothstep\fP (\fBscamera\fP< T > const &lhs, \fBscamera\fP< T > const &rhs, T const t)"
.br
.RI "Interpolate smoothly between the scamera endpoints\&. "
.ti -1c
.RI "template<typename T > \fBscamera\fP< T > \fBorbit\fP (\fBscamera\fP< T > const &camera, \fBmath::vec3\fP< T > const &focus, T const delta_phi, T const delta_theta)"
.br
.RI "Orbits \fCcamera\fP around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. "
.ti -1c
.RI "template<typename T > std::ostream & \fBoperator<<\fP (std::ostream &s, \fBscamera\fP< T > const &rhs)"
.br
.RI "Write the sccamera \fCrhs\fP to the std::ostream \fCs\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Namespace for camera-related functionality\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename T > bool stf::cam::equ (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs, T eps)\fC [inline]\fP"

.PP
Compute whether the distance between \fClhs\fP and \fCrhs\fP is less than or equal to \fCeps\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP The epsilon distance to use when computating approximate equality 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are closer than \fCeps\fP 
.RE
.PP

.SS "template<typename T > \fBscamera\fP< T > stf::cam::lerp (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs, T const t)\fC [inline]\fP"

.PP
Linearly interpolate scameras\&. 
.PP
\fBNote\fP
.RS 4
\fCt\fP is not clamped to [0, 1] (use \fBlerpstep\fP if that is desired) 
.RE
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scamera 
.RE
.PP

.SS "template<typename T > \fBscamera\fP< T > stf::cam::lerpstep (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs, T const t)\fC [inline]\fP"

.PP
Linearly interpolate scameras (clamped to the endpoint values) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scamera 
.RE
.PP

.SS "template<typename T > bool stf::cam::neq (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs, T eps)\fC [inline]\fP"

.PP
Compute whether the distance between \fClhs\fP and \fCrhs\fP is strictly greater than eps\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP The epsilon distance to use when computating approximate equality 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are further apart than \fCeps\fP 
.RE
.PP

.SS "template<typename T > bool stf::cam::operator!= (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses constants<T>::tol as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately not equal 
.RE
.PP

.SS "template<typename T > std::ostream & stf::cam::operator<< (std::ostream & s, \fBscamera\fP< T > const & rhs)"

.PP
Write the sccamera \fCrhs\fP to the std::ostream \fCs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to \fCs\fP 
.RE
.PP

.SS "template<typename T > bool stf::cam::operator== (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses constants<T>::tol as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately equal 
.RE
.PP

.SS "template<typename T > \fBscamera\fP< T > stf::cam::orbit (\fBscamera\fP< T > const & camera, \fBmath::vec3\fP< T > const & focus, T const delta_phi, T const delta_theta)\fC [inline]\fP"

.PP
Orbits \fCcamera\fP around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIcamera\fP The camera to be orbited 
.br
\fIfocus\fP Center point of the orbit 
.br
\fIdelta_phi\fP 
.br
\fIdelta_theta\fP 
.RE
.PP
\fBNote\fP
.RS 4
Angles \fCdelta_phi\fP and \fCdelta_theta\fP are spherical coordinates measured with \fCfocus\fP as the origin 
.RE
.PP
\fBReturns\fP
.RS 4
The orbited scamera 
.RE
.PP

.SS "template<typename T > \fBscamera\fP< T > stf::cam::smoothstep (\fBscamera\fP< T > const & lhs, \fBscamera\fP< T > const & rhs, T const t)\fC [inline]\fP"

.PP
Interpolate smoothly between the scamera endpoints\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scamera 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for stf from the source code\&.
