.TH "stf::math" 3 "Version 0.0.0" "stf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
stf::math \- Namespace for mathematical functionality\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBcinterval\fP"
.br
.RI "An circular interval class representing a counterclockwise connected component of the circle\&. "
.ti -1c
.RI "struct \fBconstants\fP"
.br
.RI "A templated class that has some common mathematical constants\&. "
.ti -1c
.RI "struct \fBinterval\fP"
.br
.RI "An interval class representing a connected component of the real line\&. "
.ti -1c
.RI "struct \fBmtx\fP"
.br
.RI "A square matrix class templated on number type and dimension\&. "
.ti -1c
.RI "struct \fBvec\fP"
.br
.RI "A class representing elements of R^n\&. "
.ti -1c
.RI "struct \fBvec< T, 2 >\fP"
.br
.RI "Specialization of \fBvec\fP for N=2\&. "
.ti -1c
.RI "struct \fBvec< T, 3 >\fP"
.br
.RI "Specialization of \fBvec\fP for N=3\&. "
.ti -1c
.RI "struct \fBvec< T, 4 >\fP"
.br
.RI "Specialization of \fBvec\fP for N=4\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<typename T , size_t N> using \fBbasis\fP = std::array< \fBvec\fP< T, N >, N >"
.br
.RI "Type alias for the basis of the box\&. "
.ti -1c
.RI "template<typename T > using \fBmtx2\fP = \fBmtx\fP< T, 2 >"
.br
.RI "Type alias for a 2x2 matrix\&. "
.ti -1c
.RI "template<typename T > using \fBmtx3\fP = \fBmtx\fP< T, 3 >"
.br
.RI "Type alias for a 3x3 matrix\&. "
.ti -1c
.RI "template<typename T > using \fBmtx4\fP = \fBmtx\fP< T, 4 >"
.br
.RI "Type alias for a 4x4 matrix\&. "
.ti -1c
.RI "template<typename T > using \fBvec2\fP = \fBvec\fP< T, 2 >"
.br
.RI "Type alias for a 2D \fBvec\fP\&. "
.ti -1c
.RI "template<typename T > using \fBvec3\fP = \fBvec\fP< T, 3 >"
.br
.RI "Type alias for a 3D \fBvec\fP\&. "
.ti -1c
.RI "template<typename T > using \fBvec4\fP = \fBvec\fP< T, 4 >"
.br
.RI "Type alias for a 4D \fBvec\fP\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T , size_t N> \fBbasis\fP< T, N > \fBcanonical_basis\fP ()"
.br
.RI "Compute the canonical basis for the dimension of the\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBbasis\fP< T, N > \fBto_basis\fP (\fBmtx\fP< T, N > const &rotation)"
.br
.RI "Convert a rotation matrix to a basis\&. "
.ti -1c
.RI "template<typename T > T \fBclamp_time\fP (T const t)"
.br
.RI "Clamp the input time to [0, 1]\&. "
.ti -1c
.RI "template<typename T > T \fBsmooth_time\fP (T const t)"
.br
.RI "Smooths the input time for use in smoothstep\&. "
.ti -1c
.RI "template<typename T > T \fBmad\fP (T const a, T const b, T const c)"
.br
.RI "Multiply and add instruction\&. "
.ti -1c
.RI "template<typename T > T \fBnms\fP (T const a, T const b, T const c)"
.br
.RI "Negate the result of multiply and subtract\&. "
.ti -1c
.RI "template<typename T > T \fBlerp\fP (T const a, T const b, T const t)"
.br
.RI "Linearly interpolate scalars\&. "
.ti -1c
.RI "template<typename T > T \fBlerp_inv\fP (T const a, T const b, T const x)"
.br
.RI "Compute the inverse of \fBlerp\fP\&. "
.ti -1c
.RI "template<typename T > T \fBlerpstep\fP (T const a, T const b, T const t)"
.br
.RI "Linearly interpolate scalars (clamped to the endpoint values) "
.ti -1c
.RI "template<typename T > T \fBsmoothstep\fP (T const a, T const b, T const t)"
.br
.RI "Interpolate smoothly between the scalar endpoints\&. "
.ti -1c
.RI "template<typename T > T \fBcubic_bezier\fP (T const a, T const b, T const c, T const d, T const t)"
.br
.RI "Interpolate between the four scalar anchors via a cubic bezier curve\&. "
.ti -1c
.RI "template<typename T > T \fBcubic_hermite_spline\fP (T const p0, T const m0, T const p1, T const m1, T const t)"
.br
.RI "Interpolate between scalars using cubic hermite splines\&. "
.ti -1c
.RI "template<typename T > T \fBsigmoid\fP (T const x)"
.br
.RI "Compute the sigmoid of the input\&. "
.ti -1c
.RI "template<class T , size_t N> \fBmath::vec\fP< T, N > \fBclamp\fP (\fBmath::vec\fP< T, N > const &\fBvec\fP, \fBmath::vec\fP< T, N > const &min, \fBmath::vec\fP< T, N > const &max)"
.br
.RI "Clamp a vector\&. "
.ti -1c
.RI "template<class T , size_t N> \fBmath::vec\fP< T, N > \fBclamp\fP (\fBmath::vec\fP< T, N > const &\fBvec\fP, T const min, T const max)"
.br
.RI "Clamp a vector\&. "
.ti -1c
.RI "template<class T , size_t N> \fBmath::vec\fP< T, N > \fBlerp\fP (\fBmath::vec\fP< T, N > const &a, \fBmath::vec\fP< T, N > const &b, T const t)"
.br
.RI "Linearly interpolate vectors\&. "
.ti -1c
.RI "template<class T , size_t N> \fBmath::vec\fP< T, N > \fBlerpstep\fP (\fBmath::vec\fP< T, N > const &a, \fBmath::vec\fP< T, N > const &b, T const t)"
.br
.RI "Linearly interpolate vectors (clamped to the endpoint values) "
.ti -1c
.RI "template<class T , size_t N> \fBmath::vec\fP< T, N > \fBsmoothstep\fP (\fBmath::vec\fP< T, N > const &a, \fBmath::vec\fP< T, N > const &b, T const t)"
.br
.RI "Interpolate smoothly between the vector endpoints\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBmath::vec\fP< T, N > \fBcubic_bezier\fP (\fBmath::vec\fP< T, N > const a, \fBmath::vec\fP< T, N > const b, \fBmath::vec\fP< T, N > const c, \fBmath::vec\fP< T, N > const d, T const t)"
.br
.RI "Interpolate between the four vector anchors via a cubic bezier curve\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBmath::vec\fP< T, N > \fBcubic_hermite_spline\fP (\fBmath::vec\fP< T, N > const p0, \fBmath::vec\fP< T, N > const m0, \fBmath::vec\fP< T, N > const p1, \fBmath::vec\fP< T, N > const m1, T const t)"
.br
.RI "Interpolate between vectors using cubic hermite splines\&. "
.ti -1c
.RI "template<typename T , size_t N> bool \fBoperator==\fP (\fBmtx\fP< T, N > const &lhs, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) "
.ti -1c
.RI "template<typename T , size_t N> bool \fBoperator!=\fP (\fBmtx\fP< T, N > const &lhs, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) "
.ti -1c
.RI "template<typename T , size_t N> \fBmtx\fP< T, N > \fBoperator*\fP (\fBmtx\fP< T, N > const &lhs, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Compute the product of two matrices\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator*\fP (\fBmtx\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the product of a matrix with a column vector\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator*\fP (\fBvec\fP< T, N > const &lhs, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Compute the product of a row vector with a matrix\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBmtx\fP< T, N > \fBoperator*\fP (T const lhs, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Compute the product of a matrix with a scalar\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBmtx\fP< T, N > \fBoperator*\fP (\fBmtx\fP< T, N > const &lhs, T const rhs)"
.br
.RI "Compute the product of a matrix with a scalar\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBscale\fP (\fBvec\fP< T, 3 > const &scalars)"
.br
.RI "Construct a matrix that scales in x, y, and z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBscale_x\fP (T const scalar)"
.br
.RI "Construct a matrix that scales in x\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBscale_y\fP (T const scalar)"
.br
.RI "Construct a matrix that scales in y\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBscale_z\fP (T const scalar)"
.br
.RI "Construct a matrix that scales in z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBtranslate\fP (\fBvec\fP< T, 3 > const &scalars)"
.br
.RI "Construct a matrix that translates in x, y, and z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBtranslate_x\fP (T const scalar)"
.br
.RI "Construct a matrix that translates in x\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBtranslate_y\fP (T const scalar)"
.br
.RI "Construct a matrix that translates in y\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBtranslate_z\fP (T const scalar)"
.br
.RI "Construct a matrix that translates in z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_x\fP (T const theta)"
.br
.RI "Construct a matrix that rotates about the x-axis\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_y\fP (T const theta)"
.br
.RI "Construct a matrix that rotates about the y-axis\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_z\fP (T const theta)"
.br
.RI "Construct a matrix that rotates about the z-axis\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_xyz\fP (T const x, T const y, T const z)"
.br
.RI "Compute a rotation matrix from euler angles about x -> y -> z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_xzy\fP (T const x, T const z, T const y)"
.br
.RI "Compute a rotation matrix from euler angles about x -> z -> y\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_yxz\fP (T const y, T const x, T const z)"
.br
.RI "Compute a rotation matrix from euler angles about y -> x -> z\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_yzx\fP (T const y, T const z, T const x)"
.br
.RI "Compute a rotation matrix from euler angles about y -> z -> x\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_zxy\fP (T const z, T const x, T const y)"
.br
.RI "Compute a rotation matrix from euler angles about z -> x -> y\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate_zyx\fP (T const z, T const y, T const x)"
.br
.RI "Compute a rotation matrix from euler angles about z -> y -> x\&. "
.ti -1c
.RI "template<typename T > \fBmtx\fP< T, 2 > \fBrotate\fP (T const theta)"
.br
.RI "Construct a matrix that rotates the plane\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBview\fP (\fBvec3\fP< T > const &eye, \fBvec3\fP< T > const &look, \fBvec3\fP< T > const &right, \fBvec3\fP< T > const &up)"
.br
.RI "Construct a view matrix\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBorthographic\fP (T const l, T const r, T const b, T const t, T const n, T const f)"
.br
.RI "Construct a matrix that computes an orthographic projection\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBperspective\fP (T const fov_y, T const aspect, T const near_plane, T const far_plane)"
.br
.RI "Construct a matrix that computes a perspective projection\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBrotate\fP (\fBvec\fP< T, 3 > const &axis, T const theta)"
.br
.RI "Compute a matrix that rotates 3-space around \fCaxis\fP by \fCtheta\fP\&. "
.ti -1c
.RI "template<typename T > \fBmtx4\fP< T > \fBorbit\fP (\fBvec\fP< T, 3 > const &focus, \fBvec\fP< T, 3 > const &right, T const delta_phi, T const delta_theta)"
.br
.RI "Compute a matrix that orbits 3-space around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> std::ostream & \fBoperator<<\fP (std::ostream &s, \fBmtx\fP< T, N > const &rhs)"
.br
.RI "Write the matrix \fCrhs\fP to the std::ostream \fCs\fP\&. "
.ti -1c
.RI "template<typename T > bool \fBequ\fP (T const lhs, T const rhs, T const eps)"
.br
.RI "Compute whether two scalars are less than or equal to \fCeps\fP apart\&. "
.ti -1c
.RI "template<typename T > bool \fBneq\fP (T const lhs, T const rhs, T const eps)"
.br
.RI "Compute whether two scalars are greater than \fCeps\fP apart\&. "
.ti -1c
.RI "template<typename T > T \fBto_radians\fP (T const deg)"
.br
.RI "Convert degrees to radians\&. "
.ti -1c
.RI "template<typename T > T \fBto_degrees\fP (T const rad)"
.br
.RI "Convert radieans to degrees\&. "
.ti -1c
.RI "template<typename T > T \fBcanonical_angle\fP (T const theta)"
.br
.RI "Compute the equivalent angle to \fCtheta\fP in [0, 2pi) "
.ti -1c
.RI "template<typename T > T \fBclosest_equiv_angle\fP (T const phi, T const theta)"
.br
.RI "Of all angles that are equivalent to \fCphi\fP, compute the one closest to \fCtheta\fP\&. "
.ti -1c
.RI "template<typename T > T \fBcounterclockwise_angle\fP (\fBvec2\fP< T > const &u, \fBvec2\fP< T > const &v)"
.br
.RI "Compute the counterclockwise angle from \fCu\fP to \fCv\fP\&. "
.ti -1c
.RI "template<typename T > \fBvec2\fP< T > \fBunit_vector\fP (T const theta)"
.br
.RI "Compute unit vector in the direction of \fCtheta\fP\&. "
.ti -1c
.RI "template<typename T > \fBvec3\fP< T > \fBunit_vector\fP (T const theta, T const phi)"
.br
.RI "The unit vector defined by \fCtheta\fP and \fCphi\fP\&. "
.ti -1c
.RI "template<typename T > \fBmath::vec3\fP< T > \fBto_euclidean\fP (T const radius, T const theta, T const phi)"
.br
.RI "Convert spherical coordinates to euclidean\&. "
.ti -1c
.RI "template<typename T > \fBmath::vec2\fP< T > \fBrotate\fP (\fBmath::vec2\fP< T > const &point, T const theta)"
.br
.RI "Rotate a \fCpoint\fP counterclockwise around the origin by \fCtheta\fP radians\&. "
.ti -1c
.RI "template<typename T > \fBmath::vec2\fP< T > \fBorbit\fP (\fBmath::vec2\fP< T > const &point, \fBmath::vec2\fP< T > const &focus, T const theta)"
.br
.RI "Orbit \fCpoint\fP counterclockwise around \fCfocus\fP by \fCtheta\fP radians\&. "
.ti -1c
.RI "template<typename T > \fBmath::vec3\fP< T > \fBrotate\fP (\fBmath::vec3\fP< T > const &point, \fBmath::vec3\fP< T > const &axis, T const theta)"
.br
.RI "Rotate \fCpoint\fP about \fCaxis\fP by \fCtheta\fP radians\&. "
.ti -1c
.RI "template<typename T > \fBmath::vec3\fP< T > \fBorbit\fP (\fBmath::vec3\fP< T > const &point, \fBmath::vec3\fP< T > const &focus, \fBmath::vec3\fP< T > const &right, T const delta_phi, T const delta_theta)"
.br
.RI "Orbits \fCpoint\fP around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBnormalized\fP (\fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute a normalized vector\&. "
.ti -1c
.RI "template<typename T , size_t N> T \fBdist_squared\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the square of the distance between \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> T \fBdist\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the distance between \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> bool \fBequ\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs, T const eps)"
.br
.RI "Compute whether the distance between \fClhs\fP and \fCrhs\fP is less than or equal to \fCeps\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> bool \fBneq\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs, T eps)"
.br
.RI "Compute whether the distance between \fClhs\fP and \fCrhs\fP is strictly greater than eps\&. "
.ti -1c
.RI "template<typename T , size_t N> bool \fBoperator==\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) "
.ti -1c
.RI "template<typename T , size_t N> bool \fBoperator!=\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator\-\fP (\fBvec\fP< T, N > const &lhs)"
.br
.RI "Compute the negative of \fClhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator+\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the sum of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator\-\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the difference of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator*\fP (\fBvec\fP< T, N > const &lhs, T const scalar)"
.br
.RI "Scale \fClhs\fP by \fCscalar\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator*\fP (T const scalar, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Scale \fCrhs\fP by by \fCscalar\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator/\fP (\fBvec\fP< T, N > const &lhs, T const scalar)"
.br
.RI "Divide \fClhs\fP by \fCscalar\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator/\fP (T const scalar, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Divide \fCscalar\fP by \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator/\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Divide \fClhs\fP by \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> T \fBdot\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the dot product of two vectors\&. "
.ti -1c
.RI "template<typename T , size_t N> bool \fBorthogonal\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute whethor or not two vectors are orthogonal\&. "
.ti -1c
.RI "template<typename T > T \fBcross\fP (\fBvec2\fP< T > const &lhs, \fBvec2\fP< T > const &rhs)"
.br
.RI "Compute the 2D cross product of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T > \fBvec3\fP< T > \fBcross\fP (\fBvec3\fP< T > const &lhs, \fBvec3\fP< T > const &rhs)"
.br
.RI "Compute the 3D cross product of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T > T \fBorientation\fP (\fBvec2\fP< T > const &p, \fBvec2\fP< T > const &q, \fBvec2\fP< T > const &r)"
.br
.RI "Compute the orientation of \fCp\fP, \fCq\fP, and \fCr\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBhadamard\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the hadamard product of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N > \fBoperator*\fP (\fBvec\fP< T, N > const &lhs, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the hadamard product of \fClhs\fP and \fCrhs\fP\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBvec\fP< T, N \- 1 > \fBprefix\fP (\fBvec\fP< T, N > const &rhs)"
.br
.RI "Compute the prefix of a vector\&. "
.ti -1c
.RI "template<typename T , size_t N> std::ostream & \fBoperator<<\fP (std::ostream &s, \fBvec\fP< T, N > const &rhs)"
.br
.RI "Write the vector \fCrhs\fP to the std::ostream \fCs\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Namespace for mathematical functionality\&. 
.SH "Typedef Documentation"
.PP 
.SS "template<typename T , size_t N> using \fBstf::math::basis\fP = typedef std::array<\fBvec\fP<T, N>, N>"

.PP
Type alias for the basis of the box\&. 
.PP
\fBNote\fP
.RS 4
The basis is assumed to be orthonormal
.RE
.PP
Type alias for a basis of R^n 
.PP
\fBNote\fP
.RS 4
No verification is performed 
.RE
.PP

.SS "template<typename T > using \fBstf::math::mtx2\fP = typedef \fBmtx\fP<T, 2>"

.PP
Type alias for a 2x2 matrix\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SS "template<typename T > using \fBstf::math::mtx3\fP = typedef \fBmtx\fP<T, 3>"

.PP
Type alias for a 3x3 matrix\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SS "template<typename T > using \fBstf::math::mtx4\fP = typedef \fBmtx\fP<T, 4>"

.PP
Type alias for a 4x4 matrix\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SS "template<typename T > using \fBstf::math::vec2\fP = typedef \fBvec\fP<T, 2>"

.PP
Type alias for a 2D \fBvec\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SS "template<typename T > using \fBstf::math::vec3\fP = typedef \fBvec\fP<T, 3>"

.PP
Type alias for a 3D \fBvec\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SS "template<typename T > using \fBstf::math::vec4\fP = typedef \fBvec\fP<T, 4>"

.PP
Type alias for a 4D \fBvec\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "template<typename T > T stf::math::canonical_angle (T const theta)\fC [inline]\fP"

.PP
Compute the equivalent angle to \fCtheta\fP in [0, 2pi) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The angle equivalent to \fCtheta\fP in [0, 2pi) 
.RE
.PP

.SS "template<typename T , size_t N> \fBbasis\fP< T, N > stf::math::canonical_basis ()"

.PP
Compute the canonical basis for the dimension of the\&. 
.PP
\fBReturns\fP
.RS 4
The canonical basis of R^n 
.RE
.PP

.SS "template<class T , size_t N> \fBmath::vec\fP< T, N > stf::math::clamp (\fBmath::vec\fP< T, N > const & vec, \fBmath::vec\fP< T, N > const & min, \fBmath::vec\fP< T, N > const & max)\fC [inline]\fP"

.PP
Clamp a vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIvec\fP 
.br
\fImin\fP 
.br
\fImax\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The clamped vector 
.RE
.PP

.SS "template<class T , size_t N> \fBmath::vec\fP< T, N > stf::math::clamp (\fBmath::vec\fP< T, N > const & vec, T const min, T const max)\fC [inline]\fP"

.PP
Clamp a vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIvec\fP 
.br
\fImin\fP 
.br
\fImax\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The clamped vector 
.RE
.PP

.SS "template<typename T > T stf::math::clamp_time (T const t)\fC [inline]\fP"

.PP
Clamp the input time to [0, 1]\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The input clamped to [0, 1] 
.RE
.PP

.SS "template<typename T > T stf::math::closest_equiv_angle (T const phi, T const theta)\fC [inline]\fP"

.PP
Of all angles that are equivalent to \fCphi\fP, compute the one closest to \fCtheta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIphi\fP 
.br
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The closest equivant angle of \fCphi\fP to \fCtheta\fP 
.RE
.PP

.SS "template<typename T > T stf::math::counterclockwise_angle (\fBvec2\fP< T > const & u, \fBvec2\fP< T > const & v)\fC [inline]\fP"

.PP
Compute the counterclockwise angle from \fCu\fP to \fCv\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIu\fP 
.br
\fIv\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The counterclockwise angle from \fCu\fP to \fCv\fP 
.RE
.PP

.SS "template<typename T > T stf::math::cross (\fBvec2\fP< T > const & lhs, \fBvec2\fP< T > const & rhs)\fC [inline]\fP"

.PP
Compute the 2D cross product of \fClhs\fP and \fCrhs\fP\&. This is not truely a 2D cross product\&. It is the cross product of the corresponding 3D vectors with 0 in the z coordinate\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The 2D cross product of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T > \fBvec3\fP< T > stf::math::cross (\fBvec3\fP< T > const & lhs, \fBvec3\fP< T > const & rhs)\fC [inline]\fP"

.PP
Compute the 3D cross product of \fClhs\fP and \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The 3D cross product of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBmath::vec\fP< T, N > stf::math::cubic_bezier (\fBmath::vec\fP< T, N > const a, \fBmath::vec\fP< T, N > const b, \fBmath::vec\fP< T, N > const c, \fBmath::vec\fP< T, N > const d, T const t)\fC [inline]\fP"

.PP
Interpolate between the four vector anchors via a cubic bezier curve\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIc\fP 
.br
\fId\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated vector 
.RE
.PP

.SS "template<typename T > T stf::math::cubic_bezier (T const a, T const b, T const c, T const d, T const t)\fC [inline]\fP"

.PP
Interpolate between the four scalar anchors via a cubic bezier curve\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIc\fP 
.br
\fId\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T , size_t N> \fBmath::vec\fP< T, N > stf::math::cubic_hermite_spline (\fBmath::vec\fP< T, N > const p0, \fBmath::vec\fP< T, N > const m0, \fBmath::vec\fP< T, N > const p1, \fBmath::vec\fP< T, N > const m1, T const t)\fC [inline]\fP"

.PP
Interpolate between vectors using cubic hermite splines\&. The spline function f(t) is defined on [0, 1] and satisfies the following constraints
.IP "\(bu" 2
f(0) = p0
.IP "\(bu" 2
f(1) = p1
.IP "\(bu" 2
f'(0) = m0
.IP "\(bu" 2
f'(1) = m1
.PP
.PP
This can be leveraged so that consecutive splines are C^1 at the boundary of interpolation intervals
.PP
reference: https://en.wikipedia.org/wiki/Cubic_Hermite_spline
.PP
\fBNote\fP
.RS 4
Because this function assumes a domain of [0, 1], the derivatives \fCm0\fP and \fCm1\fP must be scaled by the length of the actual interval between anchor points
.RE
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIp0\fP Anchor value at the beginning of the interpolation interval 
.br
\fIm0\fP Derivative at the beginning of the interpolation interval 
.br
\fIp1\fP Anchor value at the end of the interpolation interval 
.br
\fIm1\fP Derivative at the end of the interpolation interval 
.br
\fIt\fP Time in [0, 1] used for interpolation 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated vector 
.RE
.PP

.SS "template<typename T > T stf::math::cubic_hermite_spline (T const p0, T const m0, T const p1, T const m1, T const t)\fC [inline]\fP"

.PP
Interpolate between scalars using cubic hermite splines\&. The spline function f(t) is defined on [0, 1] and satisfies the following constraints
.IP "\(bu" 2
f(0) = p0
.IP "\(bu" 2
f(1) = p1
.IP "\(bu" 2
f'(0) = m0
.IP "\(bu" 2
f'(1) = m1
.PP
.PP
This can be leveraged so that consecutive splines are C^1 at the boundary of interpolation intervals
.PP
reference: https://en.wikipedia.org/wiki/Cubic_Hermite_spline
.PP
\fBNote\fP
.RS 4
Because this function assumes a domain of [0, 1], the derivatives \fCm0\fP and \fCm1\fP must be scaled by the length of the actual interval between anchor points
.RE
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIp0\fP Anchor value at the beginning of the interpolation interval 
.br
\fIm0\fP Derivative at the beginning of the interpolation interval 
.br
\fIp1\fP Anchor value at the end of the interpolation interval 
.br
\fIm1\fP Derivative at the end of the interpolation interval 
.br
\fIt\fP Time in [0, 1] used for interpolation 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T , size_t N> T stf::math::dist (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the distance between \fClhs\fP and \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The distance between \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> T stf::math::dist_squared (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the square of the distance between \fClhs\fP and \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The square of the distance between \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> T stf::math::dot (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the dot product of two vectors\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The dot product of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T > bool stf::math::equ (T const lhs, T const rhs, T const eps)\fC [inline]\fP"

.PP
Compute whether two scalars are less than or equal to \fCeps\fP apart\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are less than or equal to \fCeps\fP apart 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::equ (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs, T const eps)\fC [inline]\fP"

.PP
Compute whether the distance between \fClhs\fP and \fCrhs\fP is less than or equal to \fCeps\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP The epsilon distance to use when computating approximate equality 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are closer than \fCeps\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::hadamard (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the hadamard product of \fClhs\fP and \fCrhs\fP\&. The hadamard product is element-wise multiplication of vectors\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The hadamard product of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<class T , size_t N> \fBmath::vec\fP< T, N > stf::math::lerp (\fBmath::vec\fP< T, N > const & a, \fBmath::vec\fP< T, N > const & b, T const t)\fC [inline]\fP"

.PP
Linearly interpolate vectors\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated vector 
.RE
.PP

.SS "template<typename T > T stf::math::lerp (T const a, T const b, T const t)\fC [inline]\fP"

.PP
Linearly interpolate scalars\&. 
.PP
\fBNote\fP
.RS 4
\fCt\fP is not clamped to [0, 1] (use \fBlerpstep\fP if that is desired) 
.RE
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T > T stf::math::lerp_inv (T const a, T const b, T const x)\fC [inline]\fP"

.PP
Compute the inverse of \fBlerp\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIx\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The inverse of \fBlerp\fP 
.RE
.PP

.SS "template<class T , size_t N> \fBmath::vec\fP< T, N > stf::math::lerpstep (\fBmath::vec\fP< T, N > const & a, \fBmath::vec\fP< T, N > const & b, T const t)\fC [inline]\fP"

.PP
Linearly interpolate vectors (clamped to the endpoint values) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated vector 
.RE
.PP

.SS "template<typename T > T stf::math::lerpstep (T const a, T const b, T const t)\fC [inline]\fP"

.PP
Linearly interpolate scalars (clamped to the endpoint values) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T > T stf::math::mad (T const a, T const b, T const c)\fC [inline]\fP"

.PP
Multiply and add instruction\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIc\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fCa\fP * \fCb\fP + \fCc\fP 
.RE
.PP

.SS "template<typename T > bool stf::math::neq (T const lhs, T const rhs, T const eps)\fC [inline]\fP"

.PP
Compute whether two scalars are greater than \fCeps\fP apart\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are greater than \fCeps\fP apart 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::neq (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs, T eps)\fC [inline]\fP"

.PP
Compute whether the distance between \fClhs\fP and \fCrhs\fP is strictly greater than eps\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.br
\fIeps\fP The epsilon distance to use when computating approximate equality 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are further apart than \fCeps\fP 
.RE
.PP

.SS "template<typename T > T stf::math::nms (T const a, T const b, T const c)\fC [inline]\fP"

.PP
Negate the result of multiply and subtract\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIc\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fCc\fP - \fCa\fP * \fCb\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::normalized (\fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute a normalized vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
A normalized vector in the direction of \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::operator!= (\fBmtx\fP< T, N > const & lhs, \fBmtx\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately not equal 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::operator!= (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately not equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately not equal 
.RE
.PP

.SS "template<typename T , size_t N> \fBmtx\fP< T, N > stf::math::operator* (\fBmtx\fP< T, N > const & lhs, \fBmtx\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the product of two matrices\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The matrix result of the product between \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBmtx\fP< T, N > stf::math::operator* (\fBmtx\fP< T, N > const & lhs, T const rhs)\fC [inline]\fP"

.PP
Compute the product of a matrix with a scalar\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP A matrix 
.br
\fIrhs\fP A scalar 
.RE
.PP
\fBReturns\fP
.RS 4
The matrix \fClhs\fP scaled by \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator* (\fBmtx\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the product of a matrix with a column vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP A matrix 
.br
\fIrhs\fP A column vector 
.RE
.PP
\fBReturns\fP
.RS 4
The column vector result of the product between \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBmtx\fP< T, N > stf::math::operator* (T const lhs, \fBmtx\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the product of a matrix with a scalar\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP A scalar 
.br
\fIrhs\fP A matrix 
.RE
.PP
\fBReturns\fP
.RS 4
The matrix \fCrhs\fP scaled by \fClhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator* (T const scalar, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Scale \fCrhs\fP by by \fCscalar\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fCrhs\fP scaled by \fCscalar\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator* (\fBvec\fP< T, N > const & lhs, \fBmtx\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the product of a row vector with a matrix\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP A row vector 
.br
\fIrhs\fP A matrix 
.RE
.PP
\fBReturns\fP
.RS 4
The rwo vector result of the product between \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator* (\fBvec\fP< T, N > const & lhs, T const scalar)\fC [inline]\fP"

.PP
Scale \fClhs\fP by \fCscalar\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fClhs\fP scaled by \fCscalar\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator* (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the hadamard product of \fClhs\fP and \fCrhs\fP\&. The hadamard product is element-wise multiplication of vectors\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The hadamard product of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator+ (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the sum of \fClhs\fP and \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The sum of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator\- (\fBvec\fP< T, N > const & lhs)\fC [inline]\fP"

.PP
Compute the negative of \fClhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The negative of \fClhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator\- (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute the difference of \fClhs\fP and \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The difference of \fClhs\fP and \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator/ (T const scalar, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Divide \fCscalar\fP by \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fCscalar\fP divided by \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator/ (\fBvec\fP< T, N > const & lhs, T const scalar)\fC [inline]\fP"

.PP
Divide \fClhs\fP by \fCscalar\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fClhs\fP divided by \fCscalar\fP 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N > stf::math::operator/ (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Divide \fClhs\fP by \fCrhs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fClhs\fP divided by \fCrhs\fP 
.RE
.PP

.SS "template<typename T , size_t N> std::ostream & stf::math::operator<< (std::ostream & s, \fBmtx\fP< T, N > const & rhs)"

.PP
Write the matrix \fCrhs\fP to the std::ostream \fCs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to \fCs\fP 
.RE
.PP

.SS "template<typename T , size_t N> std::ostream & stf::math::operator<< (std::ostream & s, \fBvec\fP< T, N > const & rhs)"

.PP
Write the vector \fCrhs\fP to the std::ostream \fCs\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to \fCs\fP 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::operator== (\fBmtx\fP< T, N > const & lhs, \fBmtx\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately equal 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::operator== (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute whether \fClhs\fP is approximately equal to \fCrhs\fP (uses \fBconstants<T>::tol\fP as epsilon) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are approximately equal 
.RE
.PP

.SS "template<typename T > \fBmath::vec2\fP< T > stf::math::orbit (\fBmath::vec2\fP< T > const & point, \fBmath::vec2\fP< T > const & focus, T const theta)\fC [inline]\fP"

.PP
Orbit \fCpoint\fP counterclockwise around \fCfocus\fP by \fCtheta\fP radians\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP 
.br
\fIfocus\fP 
.br
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The orbited point 
.RE
.PP

.SS "template<typename T > \fBmath::vec3\fP< T > stf::math::orbit (\fBmath::vec3\fP< T > const & point, \fBmath::vec3\fP< T > const & focus, \fBmath::vec3\fP< T > const & right, T const delta_phi, T const delta_theta)\fC [inline]\fP"

.PP
Orbits \fCpoint\fP around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP 
.br
\fIfocus\fP Center point of the orbit 
.br
\fIright\fP Direction defining what direction is to the right 
.br
\fIdelta_phi\fP 
.br
\fIdelta_theta\fP 
.RE
.PP
\fBNote\fP
.RS 4
Angles \fCdelta_phi\fP and \fCdelta_theta\fP are spherical coordinates measured with \fCfocus\fP as the origin 
.PP
\fCright\fP must be a unit vector 
.RE
.PP
\fBReturns\fP
.RS 4
The orbited point 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::orbit (\fBvec\fP< T, 3 > const & focus, \fBvec\fP< T, 3 > const & right, T const delta_phi, T const delta_theta)\fC [inline]\fP"

.PP
Compute a matrix that orbits 3-space around \fCfocus\fP by \fCdelta_phi\fP and \fCdelta_theta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfocus\fP Center point of the orbit 
.br
\fIright\fP Direction defining what direction is to the right 
.br
\fIdelta_phi\fP 
.br
\fIdelta_theta\fP 
.RE
.PP
\fBNote\fP
.RS 4
Angles \fCdelta_phi\fP and \fCdelta_theta\fP are spherical coordinates measured with \fCfocus\fP as the origin 
.PP
\fCright\fP must be a unit vector 
.RE
.PP
\fBReturns\fP
.RS 4
The transformation matrix 
.RE
.PP

.SS "template<typename T > T stf::math::orientation (\fBvec2\fP< T > const & p, \fBvec2\fP< T > const & q, \fBvec2\fP< T > const & r)\fC [inline]\fP"

.PP
Compute the orientation of \fCp\fP, \fCq\fP, and \fCr\fP\&. The orientation is determined based on the sign of the return value
.IP "\(bu" 2
+ => counterclockwise
.IP "\(bu" 2
0 => colinear
.IP "\(bu" 2
- => clockwise
.PP
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIp\fP 
.br
\fIq\fP 
.br
\fIr\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The orientation of \fCp\fP, \fCq\fP, and \fCr\fP 
.RE
.PP

.SS "template<typename T , size_t N> bool stf::math::orthogonal (\fBvec\fP< T, N > const & lhs, \fBvec\fP< T, N > const & rhs)\fC [inline]\fP"

.PP
Compute whethor or not two vectors are orthogonal\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlhs\fP 
.br
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fClhs\fP and \fCrhs\fP are orthogonal 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::orthographic (T const l, T const r, T const b, T const t, T const n, T const f)\fC [inline]\fP"

.PP
Construct a matrix that computes an orthographic projection\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIl\fP Left plane 
.br
\fIr\fP Right plane 
.br
\fIb\fP Bottom plane 
.br
\fIt\fP Top plane 
.br
\fIn\fP Near plane 
.br
\fIf\fP Far plane 
.RE
.PP
\fBReturns\fP
.RS 4
The projection matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::perspective (T const fov_y, T const aspect, T const near_plane, T const far_plane)\fC [inline]\fP"

.PP
Construct a matrix that computes a perspective projection\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfov_y\fP Field of view in the y axis 
.br
\fIaspect\fP Aspect ratio (width/height = x/y) 
.br
\fInear_plane\fP Near plane 
.br
\fIfar_plane\fP Far plane 
.RE
.PP
\fBReturns\fP
.RS 4
The projection matrix 
.RE
.PP

.SS "template<typename T , size_t N> \fBvec\fP< T, N \- 1 > stf::math::prefix (\fBvec\fP< T, N > const & rhs)"

.PP
Compute the prefix of a vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.br
\fIN\fP Dimension 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The prefix of \fCrhs\fP 
.RE
.PP

.SS "template<typename T > \fBmath::vec2\fP< T > stf::math::rotate (\fBmath::vec2\fP< T > const & point, T const theta)\fC [inline]\fP"

.PP
Rotate a \fCpoint\fP counterclockwise around the origin by \fCtheta\fP radians\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP 
.br
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotated point 
.RE
.PP

.SS "template<typename T > \fBmath::vec3\fP< T > stf::math::rotate (\fBmath::vec3\fP< T > const & point, \fBmath::vec3\fP< T > const & axis, T const theta)\fC [inline]\fP"

.PP
Rotate \fCpoint\fP about \fCaxis\fP by \fCtheta\fP radians\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP 
.br
\fIaxis\fP 
.br
\fItheta\fP 
.RE
.PP
\fBNote\fP
.RS 4
\fCaxis\fP must be a unit vector 
.PP
Rotates in the direction of the right-hand rule 
.RE
.PP
\fBReturns\fP
.RS 4
The rotated point 
.RE
.PP

.SS "template<typename T > \fBmtx\fP< T, 2 > stf::math::rotate (T const theta)\fC [inline]\fP"

.PP
Construct a matrix that rotates the plane\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate (\fBvec\fP< T, 3 > const & axis, T const theta)\fC [inline]\fP"

.PP
Compute a matrix that rotates 3-space around \fCaxis\fP by \fCtheta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIaxis\fP Unit vector defining the axis of rotation 
.br
\fItheta\fP 
.RE
.PP
\fBNote\fP
.RS 4
\fCaxis\fP must be a unit vector 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_x (T const theta)\fC [inline]\fP"

.PP
Construct a matrix that rotates about the x-axis\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_xyz (T const x, T const y, T const z)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about x -> y -> z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIx\fP 
.br
\fIy\fP 
.br
\fIz\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_xzy (T const x, T const z, T const y)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about x -> z -> y\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIx\fP 
.br
\fIz\fP 
.br
\fIy\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_y (T const theta)\fC [inline]\fP"

.PP
Construct a matrix that rotates about the y-axis\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_yxz (T const y, T const x, T const z)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about y -> x -> z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIy\fP 
.br
\fIx\fP 
.br
\fIz\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_yzx (T const y, T const z, T const x)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about y -> z -> x\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIy\fP 
.br
\fIz\fP 
.br
\fIx\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_z (T const theta)\fC [inline]\fP"

.PP
Construct a matrix that rotates about the z-axis\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_zxy (T const z, T const x, T const y)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about z -> x -> y\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIz\fP 
.br
\fIx\fP 
.br
\fIy\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::rotate_zyx (T const z, T const y, T const x)\fC [inline]\fP"

.PP
Compute a rotation matrix from euler angles about z -> y -> x\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number Type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIz\fP 
.br
\fIy\fP 
.br
\fIx\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The rotation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::scale (\fBvec\fP< T, 3 > const & scalars)\fC [inline]\fP"

.PP
Construct a matrix that scales in x, y, and z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalars\fP The scalars for scaling in x, y, and z 
.RE
.PP
\fBReturns\fP
.RS 4
The scale matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::scale_x (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that scales in x\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The scale matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::scale_y (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that scales in y\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The scale matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::scale_z (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that scales in z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The scale matrix 
.RE
.PP

.SS "template<typename T > T stf::math::sigmoid (T const x)\fC [inline]\fP"

.PP
Compute the sigmoid of the input\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIx\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The output of the sigmoid function 
.RE
.PP

.SS "template<typename T > T stf::math::smooth_time (T const t)\fC [inline]\fP"

.PP
Smooths the input time for use in smoothstep\&. This function first clamps the input to s in [0, 1] and then returns s^2 * (3 - 2 * s)
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The input time smoothed close to 0 and 1 
.RE
.PP

.SS "template<class T , size_t N> \fBmath::vec\fP< T, N > stf::math::smoothstep (\fBmath::vec\fP< T, N > const & a, \fBmath::vec\fP< T, N > const & b, T const t)\fC [inline]\fP"

.PP
Interpolate smoothly between the vector endpoints\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T > T stf::math::smoothstep (T const a, T const b, T const t)\fC [inline]\fP"

.PP
Interpolate smoothly between the scalar endpoints\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fIt\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The interpolated scalar 
.RE
.PP

.SS "template<typename T , size_t N> \fBbasis\fP< T, N > stf::math::to_basis (\fBmtx\fP< T, N > const & rotation)"

.PP
Convert a rotation matrix to a basis\&. 
.PP
\fBParameters\fP
.RS 4
\fIrotation\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The basis corresponding to \fCrotation\fP 
.RE
.PP
\fBNote\fP
.RS 4
\fCrotation\fP is assumed to be orthonormal 
.RE
.PP

.SS "template<typename T > T stf::math::to_degrees (T const rad)\fC [inline]\fP"

.PP
Convert radieans to degrees\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrad\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The andle \fCrad\fP in degrees 
.RE
.PP

.SS "template<typename T > \fBmath::vec3\fP< T > stf::math::to_euclidean (T const radius, T const theta, T const phi)\fC [inline]\fP"

.PP
Convert spherical coordinates to euclidean\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIradius\fP 
.br
\fItheta\fP 
.br
\fIphi\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The euclidean coordinates 
.RE
.PP

.SS "template<typename T > T stf::math::to_radians (T const deg)\fC [inline]\fP"

.PP
Convert degrees to radians\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdeg\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The angle \fCdeg\fP in radians 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::translate (\fBvec\fP< T, 3 > const & scalars)\fC [inline]\fP"

.PP
Construct a matrix that translates in x, y, and z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalars\fP The scalars for translating in x, y, and z 
.RE
.PP
\fBReturns\fP
.RS 4
The translation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::translate_x (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that translates in x\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The translation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::translate_y (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that translates in y\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The translation matrix 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::translate_z (T const scalar)\fC [inline]\fP"

.PP
Construct a matrix that translates in z\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIscalar\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The translation matrix 
.RE
.PP

.SS "template<typename T > \fBvec2\fP< T > stf::math::unit_vector (T const theta)\fC [inline]\fP"

.PP
Compute unit vector in the direction of \fCtheta\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP An angle measured counterclockwise from (1, 0) 
.RE
.PP
\fBReturns\fP
.RS 4
The unit vector in the direction of \fCtheta\fP 
.RE
.PP

.SS "template<typename T > \fBvec3\fP< T > stf::math::unit_vector (T const theta, T const phi)\fC [inline]\fP"

.PP
The unit vector defined by \fCtheta\fP and \fCphi\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fItheta\fP An angle measured counterclockwise from (1, 0, 0) 
.br
\fIphi\fP An angle measured from (0, 0, 1) 
.RE
.PP
\fBReturns\fP
.RS 4
The unit vector defined by \fCtheta\fP and \fCphi\fP 
.RE
.PP

.SS "template<typename T > \fBmtx4\fP< T > stf::math::view (\fBvec3\fP< T > const & eye, \fBvec3\fP< T > const & look, \fBvec3\fP< T > const & right, \fBvec3\fP< T > const & up)\fC [inline]\fP"

.PP
Construct a view matrix\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Number type (eg float) 
.RE
.PP
\fBParameters\fP
.RS 4
\fIeye\fP The camera eye 
.br
\fIlook\fP The look direction 
.br
\fIright\fP The right direction 
.br
\fIup\fP The up direction 
.RE
.PP
\fBReturns\fP
.RS 4
The view matrix 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for stf from the source code\&.
