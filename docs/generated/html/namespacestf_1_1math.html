<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stf: stf::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">stf<span id="projectnumber">&#160;0.0.0</span>
   </div>
   <div id="projectbrief">A templated math library for graphics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacestf_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stf::math Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for mathematical functionality.  
<a href="namespacestf_1_1math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1cinterval.html">cinterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An circular interval class representing a counterclockwise connected component of the circle.  <a href="structstf_1_1math_1_1cinterval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated class that has some common mathematical constants.  <a href="structstf_1_1math_1_1constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1interval.html">interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interval class representing a connected component of the real line.  <a href="structstf_1_1math_1_1interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A square matrix class templated on number type and dimension.  <a href="structstf_1_1math_1_1mtx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing elements of R^n.  <a href="structstf_1_1math_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1vec_3_01T_00_012_01_4.html">vec&lt; T, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstf_1_1math_1_1vec.html">vec</a> for N=2.  <a href="structstf_1_1math_1_1vec_3_01T_00_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1vec_3_01T_00_013_01_4.html">vec&lt; T, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstf_1_1math_1_1vec.html">vec</a> for N=3.  <a href="structstf_1_1math_1_1vec_3_01T_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1math_1_1vec_3_01T_00_014_01_4.html">vec&lt; T, 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstf_1_1math_1_1vec.html">vec</a> for N=4.  <a href="structstf_1_1math_1_1vec_3_01T_00_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d8db87f09533563fde95c24959b9386" id="r_a7d8db87f09533563fde95c24959b9386"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a7d8db87f09533563fde95c24959b9386"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">basis</a> = std::array&lt; <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;, N &gt;</td></tr>
<tr class="memdesc:a7d8db87f09533563fde95c24959b9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the basis of the box.  <br /></td></tr>
<tr class="separator:a7d8db87f09533563fde95c24959b9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7972d24df5abb4b0ad2c8231b49856f4" id="r_a7972d24df5abb4b0ad2c8231b49856f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7972d24df5abb4b0ad2c8231b49856f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7972d24df5abb4b0ad2c8231b49856f4">mtx2</a> = <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:a7972d24df5abb4b0ad2c8231b49856f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 2x2 matrix.  <br /></td></tr>
<tr class="separator:a7972d24df5abb4b0ad2c8231b49856f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1267ff0a221dc2b2930639811b5b15cb" id="r_a1267ff0a221dc2b2930639811b5b15cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1267ff0a221dc2b2930639811b5b15cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a1267ff0a221dc2b2930639811b5b15cb">mtx3</a> = <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, 3 &gt;</td></tr>
<tr class="memdesc:a1267ff0a221dc2b2930639811b5b15cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 3x3 matrix.  <br /></td></tr>
<tr class="separator:a1267ff0a221dc2b2930639811b5b15cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed3bcf49ecb8bec1019fe374390d9f3" id="r_a2ed3bcf49ecb8bec1019fe374390d9f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ed3bcf49ecb8bec1019fe374390d9f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a> = <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, 4 &gt;</td></tr>
<tr class="memdesc:a2ed3bcf49ecb8bec1019fe374390d9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 4x4 matrix.  <br /></td></tr>
<tr class="separator:a2ed3bcf49ecb8bec1019fe374390d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381b50e2aee608fc1c6695bec2ce4dd6" id="r_a381b50e2aee608fc1c6695bec2ce4dd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a381b50e2aee608fc1c6695bec2ce4dd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a> = <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:a381b50e2aee608fc1c6695bec2ce4dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 2D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>.  <br /></td></tr>
<tr class="separator:a381b50e2aee608fc1c6695bec2ce4dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d320c89555c189f20dd2991d0702f6" id="r_a17d320c89555c189f20dd2991d0702f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17d320c89555c189f20dd2991d0702f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a> = <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt;</td></tr>
<tr class="memdesc:a17d320c89555c189f20dd2991d0702f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 3D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>.  <br /></td></tr>
<tr class="separator:a17d320c89555c189f20dd2991d0702f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57ace2138055062fb6af63e72001eb2" id="r_ab57ace2138055062fb6af63e72001eb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab57ace2138055062fb6af63e72001eb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ab57ace2138055062fb6af63e72001eb2">vec4</a> = <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 4 &gt;</td></tr>
<tr class="memdesc:ab57ace2138055062fb6af63e72001eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 4D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>.  <br /></td></tr>
<tr class="separator:ab57ace2138055062fb6af63e72001eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeadbd7ee49ff07cbe7ecc1f68736dda2" id="r_aeadbd7ee49ff07cbe7ecc1f68736dda2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aeadbd7ee49ff07cbe7ecc1f68736dda2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">basis</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aeadbd7ee49ff07cbe7ecc1f68736dda2">canonical_basis</a> ()</td></tr>
<tr class="memdesc:aeadbd7ee49ff07cbe7ecc1f68736dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the canonical basis for the dimension of the.  <br /></td></tr>
<tr class="separator:aeadbd7ee49ff07cbe7ecc1f68736dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea43915b87ab6b1e48e0a660d99b873" id="r_a8ea43915b87ab6b1e48e0a660d99b873"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a8ea43915b87ab6b1e48e0a660d99b873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">basis</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a8ea43915b87ab6b1e48e0a660d99b873">to_basis</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rotation)</td></tr>
<tr class="memdesc:a8ea43915b87ab6b1e48e0a660d99b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a rotation matrix to a basis.  <br /></td></tr>
<tr class="separator:a8ea43915b87ab6b1e48e0a660d99b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ddf09b4433b212a9cd307c3e54f65" id="r_a474ddf09b4433b212a9cd307c3e54f65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a474ddf09b4433b212a9cd307c3e54f65"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65">clamp_time</a> (T const t)</td></tr>
<tr class="memdesc:a474ddf09b4433b212a9cd307c3e54f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp the input time to [0, 1].  <br /></td></tr>
<tr class="separator:a474ddf09b4433b212a9cd307c3e54f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703701d9522bd2e4fabd778d35f103e5" id="r_a703701d9522bd2e4fabd778d35f103e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a703701d9522bd2e4fabd778d35f103e5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a703701d9522bd2e4fabd778d35f103e5">smooth_time</a> (T const t)</td></tr>
<tr class="memdesc:a703701d9522bd2e4fabd778d35f103e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths the input time for use in smoothstep.  <br /></td></tr>
<tr class="separator:a703701d9522bd2e4fabd778d35f103e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63af2216d6187253f38288212bfe0fb" id="r_aa63af2216d6187253f38288212bfe0fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa63af2216d6187253f38288212bfe0fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb">mad</a> (T const a, T const b, T const c)</td></tr>
<tr class="memdesc:aa63af2216d6187253f38288212bfe0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and add instruction.  <br /></td></tr>
<tr class="separator:aa63af2216d6187253f38288212bfe0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7a6357567b213ee03181eb244008d" id="r_aebd7a6357567b213ee03181eb244008d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebd7a6357567b213ee03181eb244008d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d">nms</a> (T const a, T const b, T const c)</td></tr>
<tr class="memdesc:aebd7a6357567b213ee03181eb244008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the result of multiply and subtract.  <br /></td></tr>
<tr class="separator:aebd7a6357567b213ee03181eb244008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa8ca1fb0d9248d11f7c51f93a0343" id="r_a72fa8ca1fb0d9248d11f7c51f93a0343"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72fa8ca1fb0d9248d11f7c51f93a0343"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343">lerp</a> (T const a, T const b, T const t)</td></tr>
<tr class="memdesc:a72fa8ca1fb0d9248d11f7c51f93a0343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate scalars.  <br /></td></tr>
<tr class="separator:a72fa8ca1fb0d9248d11f7c51f93a0343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350ee3c7dd0cd862d7ad1dce52cec068" id="r_a350ee3c7dd0cd862d7ad1dce52cec068"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a350ee3c7dd0cd862d7ad1dce52cec068"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a350ee3c7dd0cd862d7ad1dce52cec068">lerp_inv</a> (T const a, T const b, T const x)</td></tr>
<tr class="memdesc:a350ee3c7dd0cd862d7ad1dce52cec068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of <a class="el" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343">lerp</a>.  <br /></td></tr>
<tr class="separator:a350ee3c7dd0cd862d7ad1dce52cec068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb9c110c1fbb96aa868a4815a07326" id="r_a05eb9c110c1fbb96aa868a4815a07326"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05eb9c110c1fbb96aa868a4815a07326"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a05eb9c110c1fbb96aa868a4815a07326">lerpstep</a> (T const a, T const b, T const t)</td></tr>
<tr class="memdesc:a05eb9c110c1fbb96aa868a4815a07326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate scalars (clamped to the endpoint values)  <br /></td></tr>
<tr class="separator:a05eb9c110c1fbb96aa868a4815a07326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8137cac1b4235e147e53d3a86180a1" id="r_abc8137cac1b4235e147e53d3a86180a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc8137cac1b4235e147e53d3a86180a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#abc8137cac1b4235e147e53d3a86180a1">smoothstep</a> (T const a, T const b, T const t)</td></tr>
<tr class="memdesc:abc8137cac1b4235e147e53d3a86180a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate smoothly between the scalar endpoints.  <br /></td></tr>
<tr class="separator:abc8137cac1b4235e147e53d3a86180a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849132b25c2ba3d20162b29baf00b74" id="r_a6849132b25c2ba3d20162b29baf00b74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6849132b25c2ba3d20162b29baf00b74"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a6849132b25c2ba3d20162b29baf00b74">cubic_bezier</a> (T const a, T const b, T const c, T const d, T const t)</td></tr>
<tr class="memdesc:a6849132b25c2ba3d20162b29baf00b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate between the four scalar anchors via a cubic bezier curve.  <br /></td></tr>
<tr class="separator:a6849132b25c2ba3d20162b29baf00b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c918df85e92af354a00b828bb12e26" id="r_ad7c918df85e92af354a00b828bb12e26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7c918df85e92af354a00b828bb12e26"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ad7c918df85e92af354a00b828bb12e26">cubic_hermite_spline</a> (T const p0, T const m0, T const p1, T const m1, T const t)</td></tr>
<tr class="memdesc:ad7c918df85e92af354a00b828bb12e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate between scalars using cubic hermite splines.  <br /></td></tr>
<tr class="separator:ad7c918df85e92af354a00b828bb12e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb4a3b24b4f682a650ba5a9c1b9ad63" id="r_a8eb4a3b24b4f682a650ba5a9c1b9ad63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8eb4a3b24b4f682a650ba5a9c1b9ad63"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a8eb4a3b24b4f682a650ba5a9c1b9ad63">sigmoid</a> (T const x)</td></tr>
<tr class="memdesc:a8eb4a3b24b4f682a650ba5a9c1b9ad63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sigmoid of the input.  <br /></td></tr>
<tr class="separator:a8eb4a3b24b4f682a650ba5a9c1b9ad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434400353fc8f81cbea4653948b7dadd" id="r_a434400353fc8f81cbea4653948b7dadd"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a434400353fc8f81cbea4653948b7dadd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a434400353fc8f81cbea4653948b7dadd">clamp</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;min, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;max)</td></tr>
<tr class="memdesc:a434400353fc8f81cbea4653948b7dadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a vector.  <br /></td></tr>
<tr class="separator:a434400353fc8f81cbea4653948b7dadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8507043fb1a54219335dbc7fe197e3" id="r_a7f8507043fb1a54219335dbc7fe197e3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a7f8507043fb1a54219335dbc7fe197e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7f8507043fb1a54219335dbc7fe197e3">clamp</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>, T const min, T const max)</td></tr>
<tr class="memdesc:a7f8507043fb1a54219335dbc7fe197e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a vector.  <br /></td></tr>
<tr class="separator:a7f8507043fb1a54219335dbc7fe197e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc59c171c2d2950a06a0f4efaa257027" id="r_acc59c171c2d2950a06a0f4efaa257027"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:acc59c171c2d2950a06a0f4efaa257027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#acc59c171c2d2950a06a0f4efaa257027">lerp</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;a, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;b, T const t)</td></tr>
<tr class="memdesc:acc59c171c2d2950a06a0f4efaa257027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate vectors.  <br /></td></tr>
<tr class="separator:acc59c171c2d2950a06a0f4efaa257027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae5e01d51e37ee6de1d186e5548264" id="r_acbae5e01d51e37ee6de1d186e5548264"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:acbae5e01d51e37ee6de1d186e5548264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#acbae5e01d51e37ee6de1d186e5548264">lerpstep</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;a, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;b, T const t)</td></tr>
<tr class="memdesc:acbae5e01d51e37ee6de1d186e5548264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate vectors (clamped to the endpoint values)  <br /></td></tr>
<tr class="separator:acbae5e01d51e37ee6de1d186e5548264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6aefbf6bcff077cfb2d540bff3d65a" id="r_aaf6aefbf6bcff077cfb2d540bff3d65a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:aaf6aefbf6bcff077cfb2d540bff3d65a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aaf6aefbf6bcff077cfb2d540bff3d65a">smoothstep</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;a, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;b, T const t)</td></tr>
<tr class="memdesc:aaf6aefbf6bcff077cfb2d540bff3d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate smoothly between the vector endpoints.  <br /></td></tr>
<tr class="separator:aaf6aefbf6bcff077cfb2d540bff3d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b0486cc93b9945e1c443fe33ed8c1" id="r_a0f0b0486cc93b9945e1c443fe33ed8c1"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0f0b0486cc93b9945e1c443fe33ed8c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a0f0b0486cc93b9945e1c443fe33ed8c1">cubic_bezier</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const a, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const b, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const c, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const d, T const t)</td></tr>
<tr class="memdesc:a0f0b0486cc93b9945e1c443fe33ed8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate between the four vector anchors via a cubic bezier curve.  <br /></td></tr>
<tr class="separator:a0f0b0486cc93b9945e1c443fe33ed8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d627aaad69305e68a9afe0bcb1a15f" id="r_a14d627aaad69305e68a9afe0bcb1a15f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a14d627aaad69305e68a9afe0bcb1a15f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a14d627aaad69305e68a9afe0bcb1a15f">cubic_hermite_spline</a> (<a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const p0, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const m0, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const p1, <a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const m1, T const t)</td></tr>
<tr class="memdesc:a14d627aaad69305e68a9afe0bcb1a15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate between vectors using cubic hermite splines.  <br /></td></tr>
<tr class="separator:a14d627aaad69305e68a9afe0bcb1a15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaa2d59adfc9bcc1bd31520839ef4ac" id="r_afcaa2d59adfc9bcc1bd31520839ef4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:afcaa2d59adfc9bcc1bd31520839ef4ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#afcaa2d59adfc9bcc1bd31520839ef4ac">operator==</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:afcaa2d59adfc9bcc1bd31520839ef4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether <code>lhs</code> is approximately equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon)  <br /></td></tr>
<tr class="separator:afcaa2d59adfc9bcc1bd31520839ef4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f54de1a174b97ed2fd04fb028c7cfa" id="r_a55f54de1a174b97ed2fd04fb028c7cfa"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a55f54de1a174b97ed2fd04fb028c7cfa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a55f54de1a174b97ed2fd04fb028c7cfa">operator!=</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a55f54de1a174b97ed2fd04fb028c7cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether <code>lhs</code> is approximately not equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon)  <br /></td></tr>
<tr class="separator:a55f54de1a174b97ed2fd04fb028c7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf9f153e5f4aab36419f0dff6418ae" id="r_a39cf9f153e5f4aab36419f0dff6418ae"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a39cf9f153e5f4aab36419f0dff6418ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a39cf9f153e5f4aab36419f0dff6418ae">operator*</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a39cf9f153e5f4aab36419f0dff6418ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of two matrices.  <br /></td></tr>
<tr class="separator:a39cf9f153e5f4aab36419f0dff6418ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1ad0efcc79d0924035966014cc02b" id="r_abbd1ad0efcc79d0924035966014cc02b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:abbd1ad0efcc79d0924035966014cc02b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#abbd1ad0efcc79d0924035966014cc02b">operator*</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:abbd1ad0efcc79d0924035966014cc02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a matrix with a column vector.  <br /></td></tr>
<tr class="separator:abbd1ad0efcc79d0924035966014cc02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff984cc94229e85cde5f93291f2216d" id="r_acff984cc94229e85cde5f93291f2216d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:acff984cc94229e85cde5f93291f2216d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#acff984cc94229e85cde5f93291f2216d">operator*</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:acff984cc94229e85cde5f93291f2216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a row vector with a matrix.  <br /></td></tr>
<tr class="separator:acff984cc94229e85cde5f93291f2216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b52c08ea5d277592d46370d75a893b2" id="r_a1b52c08ea5d277592d46370d75a893b2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a1b52c08ea5d277592d46370d75a893b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a1b52c08ea5d277592d46370d75a893b2">operator*</a> (T const lhs, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a1b52c08ea5d277592d46370d75a893b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a matrix with a scalar.  <br /></td></tr>
<tr class="separator:a1b52c08ea5d277592d46370d75a893b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f480af805f0ea755daeb6b38a02070" id="r_a62f480af805f0ea755daeb6b38a02070"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a62f480af805f0ea755daeb6b38a02070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a62f480af805f0ea755daeb6b38a02070">operator*</a> (<a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;lhs, T const rhs)</td></tr>
<tr class="memdesc:a62f480af805f0ea755daeb6b38a02070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a matrix with a scalar.  <br /></td></tr>
<tr class="separator:a62f480af805f0ea755daeb6b38a02070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612899b7860d515c5908b0410c0555ba" id="r_a612899b7860d515c5908b0410c0555ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a612899b7860d515c5908b0410c0555ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a612899b7860d515c5908b0410c0555ba">scale</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;scalars)</td></tr>
<tr class="memdesc:a612899b7860d515c5908b0410c0555ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that scales in x, y, and z.  <br /></td></tr>
<tr class="separator:a612899b7860d515c5908b0410c0555ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e24a954343bbe7eeeec8af9f2550cf3" id="r_a6e24a954343bbe7eeeec8af9f2550cf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e24a954343bbe7eeeec8af9f2550cf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a6e24a954343bbe7eeeec8af9f2550cf3">scale_x</a> (T const scalar)</td></tr>
<tr class="memdesc:a6e24a954343bbe7eeeec8af9f2550cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that scales in x.  <br /></td></tr>
<tr class="separator:a6e24a954343bbe7eeeec8af9f2550cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46513ba64d6968b3462b6686c11b8169" id="r_a46513ba64d6968b3462b6686c11b8169"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46513ba64d6968b3462b6686c11b8169"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a46513ba64d6968b3462b6686c11b8169">scale_y</a> (T const scalar)</td></tr>
<tr class="memdesc:a46513ba64d6968b3462b6686c11b8169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that scales in y.  <br /></td></tr>
<tr class="separator:a46513ba64d6968b3462b6686c11b8169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a64817a9e20e05dbda0fc34eb46a13b" id="r_a7a64817a9e20e05dbda0fc34eb46a13b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a64817a9e20e05dbda0fc34eb46a13b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7a64817a9e20e05dbda0fc34eb46a13b">scale_z</a> (T const scalar)</td></tr>
<tr class="memdesc:a7a64817a9e20e05dbda0fc34eb46a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that scales in z.  <br /></td></tr>
<tr class="separator:a7a64817a9e20e05dbda0fc34eb46a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d854bb00563557b5ade45a95f671c2" id="r_af4d854bb00563557b5ade45a95f671c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4d854bb00563557b5ade45a95f671c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#af4d854bb00563557b5ade45a95f671c2">translate</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;scalars)</td></tr>
<tr class="memdesc:af4d854bb00563557b5ade45a95f671c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that translates in x, y, and z.  <br /></td></tr>
<tr class="separator:af4d854bb00563557b5ade45a95f671c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a864dfaf88a1974acada6da7f4f94e1" id="r_a2a864dfaf88a1974acada6da7f4f94e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a864dfaf88a1974acada6da7f4f94e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2a864dfaf88a1974acada6da7f4f94e1">translate_x</a> (T const scalar)</td></tr>
<tr class="memdesc:a2a864dfaf88a1974acada6da7f4f94e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that translates in x.  <br /></td></tr>
<tr class="separator:a2a864dfaf88a1974acada6da7f4f94e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b2e16574bb1b729ae2a7d1d45f614" id="r_a410b2e16574bb1b729ae2a7d1d45f614"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a410b2e16574bb1b729ae2a7d1d45f614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a410b2e16574bb1b729ae2a7d1d45f614">translate_y</a> (T const scalar)</td></tr>
<tr class="memdesc:a410b2e16574bb1b729ae2a7d1d45f614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that translates in y.  <br /></td></tr>
<tr class="separator:a410b2e16574bb1b729ae2a7d1d45f614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7655d5d1e7c17f9983c7b1b90e8ccb0" id="r_ae7655d5d1e7c17f9983c7b1b90e8ccb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7655d5d1e7c17f9983c7b1b90e8ccb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ae7655d5d1e7c17f9983c7b1b90e8ccb0">translate_z</a> (T const scalar)</td></tr>
<tr class="memdesc:ae7655d5d1e7c17f9983c7b1b90e8ccb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that translates in z.  <br /></td></tr>
<tr class="separator:ae7655d5d1e7c17f9983c7b1b90e8ccb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737334e3c401872dbba6373d5129e37a" id="r_a737334e3c401872dbba6373d5129e37a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a737334e3c401872dbba6373d5129e37a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a">rotate_x</a> (T const theta)</td></tr>
<tr class="memdesc:a737334e3c401872dbba6373d5129e37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that rotates about the x-axis.  <br /></td></tr>
<tr class="separator:a737334e3c401872dbba6373d5129e37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad16652641fafa59b53ca322306033a" id="r_afad16652641fafa59b53ca322306033a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afad16652641fafa59b53ca322306033a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a">rotate_y</a> (T const theta)</td></tr>
<tr class="memdesc:afad16652641fafa59b53ca322306033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that rotates about the y-axis.  <br /></td></tr>
<tr class="separator:afad16652641fafa59b53ca322306033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d93411a1a0faaf2c7b8d972921fd9a1" id="r_a2d93411a1a0faaf2c7b8d972921fd9a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d93411a1a0faaf2c7b8d972921fd9a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1">rotate_z</a> (T const theta)</td></tr>
<tr class="memdesc:a2d93411a1a0faaf2c7b8d972921fd9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that rotates about the z-axis.  <br /></td></tr>
<tr class="separator:a2d93411a1a0faaf2c7b8d972921fd9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee4048611ec798c4c6401c07f7c50ea" id="r_a7ee4048611ec798c4c6401c07f7c50ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ee4048611ec798c4c6401c07f7c50ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7ee4048611ec798c4c6401c07f7c50ea">rotate_xyz</a> (T const x, T const y, T const z)</td></tr>
<tr class="memdesc:a7ee4048611ec798c4c6401c07f7c50ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about x -&gt; y -&gt; z.  <br /></td></tr>
<tr class="separator:a7ee4048611ec798c4c6401c07f7c50ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9215b95071d6d7d2d4c4b22eab3f2e" id="r_a7f9215b95071d6d7d2d4c4b22eab3f2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f9215b95071d6d7d2d4c4b22eab3f2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7f9215b95071d6d7d2d4c4b22eab3f2e">rotate_xzy</a> (T const x, T const z, T const y)</td></tr>
<tr class="memdesc:a7f9215b95071d6d7d2d4c4b22eab3f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about x -&gt; z -&gt; y.  <br /></td></tr>
<tr class="separator:a7f9215b95071d6d7d2d4c4b22eab3f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dca47ef149554a8c019d9f933293fb5" id="r_a7dca47ef149554a8c019d9f933293fb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7dca47ef149554a8c019d9f933293fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7dca47ef149554a8c019d9f933293fb5">rotate_yxz</a> (T const y, T const x, T const z)</td></tr>
<tr class="memdesc:a7dca47ef149554a8c019d9f933293fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about y -&gt; x -&gt; z.  <br /></td></tr>
<tr class="separator:a7dca47ef149554a8c019d9f933293fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90da77373133ebf5cdfca8f10e5b8b98" id="r_a90da77373133ebf5cdfca8f10e5b8b98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90da77373133ebf5cdfca8f10e5b8b98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a90da77373133ebf5cdfca8f10e5b8b98">rotate_yzx</a> (T const y, T const z, T const x)</td></tr>
<tr class="memdesc:a90da77373133ebf5cdfca8f10e5b8b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about y -&gt; z -&gt; x.  <br /></td></tr>
<tr class="separator:a90da77373133ebf5cdfca8f10e5b8b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ff3d05c9d50e07a653639e95c3e68" id="r_aaf3ff3d05c9d50e07a653639e95c3e68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3ff3d05c9d50e07a653639e95c3e68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aaf3ff3d05c9d50e07a653639e95c3e68">rotate_zxy</a> (T const z, T const x, T const y)</td></tr>
<tr class="memdesc:aaf3ff3d05c9d50e07a653639e95c3e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about z -&gt; x -&gt; y.  <br /></td></tr>
<tr class="separator:aaf3ff3d05c9d50e07a653639e95c3e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f2f84893853e32ac7276fa6cb5f910" id="r_a48f2f84893853e32ac7276fa6cb5f910"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48f2f84893853e32ac7276fa6cb5f910"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a48f2f84893853e32ac7276fa6cb5f910">rotate_zyx</a> (T const z, T const y, T const x)</td></tr>
<tr class="memdesc:a48f2f84893853e32ac7276fa6cb5f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a rotation matrix from euler angles about z -&gt; y -&gt; x.  <br /></td></tr>
<tr class="separator:a48f2f84893853e32ac7276fa6cb5f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fc2acde1310e70f82f9eaed0efd4be" id="r_a39fc2acde1310e70f82f9eaed0efd4be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39fc2acde1310e70f82f9eaed0efd4be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a39fc2acde1310e70f82f9eaed0efd4be">rotate</a> (T const theta)</td></tr>
<tr class="memdesc:a39fc2acde1310e70f82f9eaed0efd4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that rotates the plane.  <br /></td></tr>
<tr class="separator:a39fc2acde1310e70f82f9eaed0efd4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec55e14ebb462574ee6b87b715edb28" id="r_a3ec55e14ebb462574ee6b87b715edb28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ec55e14ebb462574ee6b87b715edb28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a3ec55e14ebb462574ee6b87b715edb28">view</a> (<a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;eye, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;look, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;right, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;up)</td></tr>
<tr class="memdesc:a3ec55e14ebb462574ee6b87b715edb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a view matrix.  <br /></td></tr>
<tr class="separator:a3ec55e14ebb462574ee6b87b715edb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb871750293406b66f28588585cd19d" id="r_a7cb871750293406b66f28588585cd19d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cb871750293406b66f28588585cd19d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7cb871750293406b66f28588585cd19d">orthographic</a> (T const l, T const r, T const b, T const t, T const n, T const f)</td></tr>
<tr class="memdesc:a7cb871750293406b66f28588585cd19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that computes an orthographic projection.  <br /></td></tr>
<tr class="separator:a7cb871750293406b66f28588585cd19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dff4c8f71f49ac7c84da50160f40bf" id="r_af2dff4c8f71f49ac7c84da50160f40bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2dff4c8f71f49ac7c84da50160f40bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#af2dff4c8f71f49ac7c84da50160f40bf">perspective</a> (T const fov_y, T const aspect, T const near_plane, T const far_plane)</td></tr>
<tr class="memdesc:af2dff4c8f71f49ac7c84da50160f40bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that computes a perspective projection.  <br /></td></tr>
<tr class="separator:af2dff4c8f71f49ac7c84da50160f40bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea46e60693618742f4f30609517dd6a6" id="r_aea46e60693618742f4f30609517dd6a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea46e60693618742f4f30609517dd6a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aea46e60693618742f4f30609517dd6a6">rotate</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;axis, T const theta)</td></tr>
<tr class="memdesc:aea46e60693618742f4f30609517dd6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a matrix that rotates 3-space around <code>axis</code> by <code>theta</code>.  <br /></td></tr>
<tr class="separator:aea46e60693618742f4f30609517dd6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da3ef5bf72ec943c212645e65bc7bc8" id="r_a5da3ef5bf72ec943c212645e65bc7bc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5da3ef5bf72ec943c212645e65bc7bc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a5da3ef5bf72ec943c212645e65bc7bc8">orbit</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;focus, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;right, T const delta_phi, T const delta_theta)</td></tr>
<tr class="memdesc:a5da3ef5bf72ec943c212645e65bc7bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a matrix that orbits 3-space around <code>focus</code> by <code>delta_phi</code> and <code>delta_theta</code>.  <br /></td></tr>
<tr class="separator:a5da3ef5bf72ec943c212645e65bc7bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a0cc4102350850b1b23d37cd67a79" id="r_a587a0cc4102350850b1b23d37cd67a79"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a587a0cc4102350850b1b23d37cd67a79"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a587a0cc4102350850b1b23d37cd67a79">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a587a0cc4102350850b1b23d37cd67a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the matrix <code>rhs</code> to the std::ostream <code>s</code>.  <br /></td></tr>
<tr class="separator:a587a0cc4102350850b1b23d37cd67a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8456a9732b6af9e5b7d05675efabf42a" id="r_a8456a9732b6af9e5b7d05675efabf42a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8456a9732b6af9e5b7d05675efabf42a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a8456a9732b6af9e5b7d05675efabf42a">equ</a> (T const lhs, T const rhs, T const eps)</td></tr>
<tr class="memdesc:a8456a9732b6af9e5b7d05675efabf42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether two scalars are less than or equal to <code>eps</code> apart.  <br /></td></tr>
<tr class="separator:a8456a9732b6af9e5b7d05675efabf42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9777f4cdd2384cf37748bcb11f0d1d02" id="r_a9777f4cdd2384cf37748bcb11f0d1d02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9777f4cdd2384cf37748bcb11f0d1d02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a9777f4cdd2384cf37748bcb11f0d1d02">neq</a> (T const lhs, T const rhs, T const eps)</td></tr>
<tr class="memdesc:a9777f4cdd2384cf37748bcb11f0d1d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether two scalars are greater than <code>eps</code> apart.  <br /></td></tr>
<tr class="separator:a9777f4cdd2384cf37748bcb11f0d1d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb991336cd40e9b939bc08400bbd41b3" id="r_aeb991336cd40e9b939bc08400bbd41b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb991336cd40e9b939bc08400bbd41b3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aeb991336cd40e9b939bc08400bbd41b3">to_radians</a> (T const deg)</td></tr>
<tr class="memdesc:aeb991336cd40e9b939bc08400bbd41b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <br /></td></tr>
<tr class="separator:aeb991336cd40e9b939bc08400bbd41b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db343b05b5137368f26a08ace47a94b" id="r_a0db343b05b5137368f26a08ace47a94b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0db343b05b5137368f26a08ace47a94b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a0db343b05b5137368f26a08ace47a94b">to_degrees</a> (T const rad)</td></tr>
<tr class="memdesc:a0db343b05b5137368f26a08ace47a94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radieans to degrees.  <br /></td></tr>
<tr class="separator:a0db343b05b5137368f26a08ace47a94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2888d4e52fada9facf208ac2235b119d" id="r_a2888d4e52fada9facf208ac2235b119d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2888d4e52fada9facf208ac2235b119d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2888d4e52fada9facf208ac2235b119d">canonical_angle</a> (T const theta)</td></tr>
<tr class="memdesc:a2888d4e52fada9facf208ac2235b119d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the equivalent angle to <code>theta</code> in [0, 2pi)  <br /></td></tr>
<tr class="separator:a2888d4e52fada9facf208ac2235b119d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66769992feb7b50f12976d9ebcc16580" id="r_a66769992feb7b50f12976d9ebcc16580"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66769992feb7b50f12976d9ebcc16580"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a66769992feb7b50f12976d9ebcc16580">closest_equiv_angle</a> (T const phi, T const theta)</td></tr>
<tr class="memdesc:a66769992feb7b50f12976d9ebcc16580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Of all angles that are equivalent to <code>phi</code>, compute the one closest to <code>theta</code>.  <br /></td></tr>
<tr class="separator:a66769992feb7b50f12976d9ebcc16580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25def3b146b03aee8ca35a9cb00e0e" id="r_a1f25def3b146b03aee8ca35a9cb00e0e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f25def3b146b03aee8ca35a9cb00e0e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a1f25def3b146b03aee8ca35a9cb00e0e">counterclockwise_angle</a> (<a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;u, <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;v)</td></tr>
<tr class="memdesc:a1f25def3b146b03aee8ca35a9cb00e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the counterclockwise angle from <code>u</code> to <code>v</code>.  <br /></td></tr>
<tr class="separator:a1f25def3b146b03aee8ca35a9cb00e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731976438129a4b458e42de14270eaae" id="r_a731976438129a4b458e42de14270eaae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a731976438129a4b458e42de14270eaae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a731976438129a4b458e42de14270eaae">unit_vector</a> (T const theta)</td></tr>
<tr class="memdesc:a731976438129a4b458e42de14270eaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unit vector in the direction of <code>theta</code>.  <br /></td></tr>
<tr class="separator:a731976438129a4b458e42de14270eaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c445b1dfe2d55a7761bf111fb12fb" id="r_a182c445b1dfe2d55a7761bf111fb12fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a182c445b1dfe2d55a7761bf111fb12fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a182c445b1dfe2d55a7761bf111fb12fb">unit_vector</a> (T const theta, T const phi)</td></tr>
<tr class="memdesc:a182c445b1dfe2d55a7761bf111fb12fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit vector defined by <code>theta</code> and <code>phi</code>.  <br /></td></tr>
<tr class="separator:a182c445b1dfe2d55a7761bf111fb12fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20df763f820598019d628e96c1916b8" id="r_ab20df763f820598019d628e96c1916b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab20df763f820598019d628e96c1916b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ab20df763f820598019d628e96c1916b8">to_euclidean</a> (T const radius, T const theta, T const phi)</td></tr>
<tr class="memdesc:ab20df763f820598019d628e96c1916b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert spherical coordinates to euclidean.  <br /></td></tr>
<tr class="separator:ab20df763f820598019d628e96c1916b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265d68afa219be711bd357931cbcdbe" id="r_ad265d68afa219be711bd357931cbcdbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad265d68afa219be711bd357931cbcdbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ad265d68afa219be711bd357931cbcdbe">rotate</a> (<a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;point, T const theta)</td></tr>
<tr class="memdesc:ad265d68afa219be711bd357931cbcdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a <code>point</code> counterclockwise around the origin by <code>theta</code> radians.  <br /></td></tr>
<tr class="separator:ad265d68afa219be711bd357931cbcdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e" id="r_a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e">orbit</a> (<a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;point, <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;focus, T const theta)</td></tr>
<tr class="memdesc:a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbit <code>point</code> counterclockwise around <code>focus</code> by <code>theta</code> radians.  <br /></td></tr>
<tr class="separator:a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2356bb1c31343cbaf5e21cae3467c702" id="r_a2356bb1c31343cbaf5e21cae3467c702"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2356bb1c31343cbaf5e21cae3467c702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2356bb1c31343cbaf5e21cae3467c702">rotate</a> (<a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;point, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;axis, T const theta)</td></tr>
<tr class="memdesc:a2356bb1c31343cbaf5e21cae3467c702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate <code>point</code> about <code>axis</code> by <code>theta</code> radians.  <br /></td></tr>
<tr class="separator:a2356bb1c31343cbaf5e21cae3467c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82d7ca9b879c363c96ff47bc4a75ff1" id="r_ad82d7ca9b879c363c96ff47bc4a75ff1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad82d7ca9b879c363c96ff47bc4a75ff1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ad82d7ca9b879c363c96ff47bc4a75ff1">orbit</a> (<a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;point, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;focus, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;right, T const delta_phi, T const delta_theta)</td></tr>
<tr class="memdesc:ad82d7ca9b879c363c96ff47bc4a75ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbits <code>point</code> around <code>focus</code> by <code>delta_phi</code> and <code>delta_theta</code>.  <br /></td></tr>
<tr class="separator:ad82d7ca9b879c363c96ff47bc4a75ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5dd0464edba36002bede9ab75a9007" id="r_a5f5dd0464edba36002bede9ab75a9007"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a5f5dd0464edba36002bede9ab75a9007"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a5f5dd0464edba36002bede9ab75a9007">normalized</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a5f5dd0464edba36002bede9ab75a9007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a normalized vector.  <br /></td></tr>
<tr class="separator:a5f5dd0464edba36002bede9ab75a9007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82b998efe770c215834daefd24494d9" id="r_ad82b998efe770c215834daefd24494d9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad82b998efe770c215834daefd24494d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ad82b998efe770c215834daefd24494d9">dist_squared</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ad82b998efe770c215834daefd24494d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of the distance between <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:ad82b998efe770c215834daefd24494d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbb8839da3544d5ca8a34863bdc8250" id="r_a0cbb8839da3544d5ca8a34863bdc8250"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0cbb8839da3544d5ca8a34863bdc8250"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a0cbb8839da3544d5ca8a34863bdc8250">dist</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a0cbb8839da3544d5ca8a34863bdc8250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a0cbb8839da3544d5ca8a34863bdc8250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a165fa37e0a48b01bf684ff5b9841b" id="r_ab1a165fa37e0a48b01bf684ff5b9841b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab1a165fa37e0a48b01bf684ff5b9841b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ab1a165fa37e0a48b01bf684ff5b9841b">equ</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs, T const eps)</td></tr>
<tr class="memdesc:ab1a165fa37e0a48b01bf684ff5b9841b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the distance between <code>lhs</code> and <code>rhs</code> is less than or equal to <code>eps</code>.  <br /></td></tr>
<tr class="separator:ab1a165fa37e0a48b01bf684ff5b9841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ad82333f9d392826685c90ef60dc0" id="r_a2f9ad82333f9d392826685c90ef60dc0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2f9ad82333f9d392826685c90ef60dc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2f9ad82333f9d392826685c90ef60dc0">neq</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs, T eps)</td></tr>
<tr class="memdesc:a2f9ad82333f9d392826685c90ef60dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the distance between <code>lhs</code> and <code>rhs</code> is strictly greater than eps.  <br /></td></tr>
<tr class="separator:a2f9ad82333f9d392826685c90ef60dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9c8bbaf1ecfa3bf3854b0370f9100" id="r_a78f9c8bbaf1ecfa3bf3854b0370f9100"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a78f9c8bbaf1ecfa3bf3854b0370f9100"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a78f9c8bbaf1ecfa3bf3854b0370f9100">operator==</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a78f9c8bbaf1ecfa3bf3854b0370f9100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether <code>lhs</code> is approximately equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon)  <br /></td></tr>
<tr class="separator:a78f9c8bbaf1ecfa3bf3854b0370f9100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060fc51c289538296b2c6ed408e85561" id="r_a060fc51c289538296b2c6ed408e85561"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a060fc51c289538296b2c6ed408e85561"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a060fc51c289538296b2c6ed408e85561">operator!=</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a060fc51c289538296b2c6ed408e85561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether <code>lhs</code> is approximately not equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon)  <br /></td></tr>
<tr class="separator:a060fc51c289538296b2c6ed408e85561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338018216d27c5977be3fc2547b13eae" id="r_a338018216d27c5977be3fc2547b13eae"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a338018216d27c5977be3fc2547b13eae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a338018216d27c5977be3fc2547b13eae">operator-</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs)</td></tr>
<tr class="memdesc:a338018216d27c5977be3fc2547b13eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the negative of <code>lhs</code>.  <br /></td></tr>
<tr class="separator:a338018216d27c5977be3fc2547b13eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b03c736e9e3277e531edc1444394f97" id="r_a0b03c736e9e3277e531edc1444394f97"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0b03c736e9e3277e531edc1444394f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a0b03c736e9e3277e531edc1444394f97">operator+</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a0b03c736e9e3277e531edc1444394f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a0b03c736e9e3277e531edc1444394f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9226c463ed313249dbf70933a70e2c" id="r_a4c9226c463ed313249dbf70933a70e2c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4c9226c463ed313249dbf70933a70e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a4c9226c463ed313249dbf70933a70e2c">operator-</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a4c9226c463ed313249dbf70933a70e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the difference of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a4c9226c463ed313249dbf70933a70e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf64d4c24380f9e73c146ad14e2187f9" id="r_abf64d4c24380f9e73c146ad14e2187f9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:abf64d4c24380f9e73c146ad14e2187f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#abf64d4c24380f9e73c146ad14e2187f9">operator*</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, T const scalar)</td></tr>
<tr class="memdesc:abf64d4c24380f9e73c146ad14e2187f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>lhs</code> by <code>scalar</code>.  <br /></td></tr>
<tr class="separator:abf64d4c24380f9e73c146ad14e2187f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ea300f09e4777ce13929e09e41f437" id="r_a76ea300f09e4777ce13929e09e41f437"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a76ea300f09e4777ce13929e09e41f437"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a76ea300f09e4777ce13929e09e41f437">operator*</a> (T const scalar, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a76ea300f09e4777ce13929e09e41f437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>rhs</code> by by <code>scalar</code>.  <br /></td></tr>
<tr class="separator:a76ea300f09e4777ce13929e09e41f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a07ba0e377d3de3df8722b5badd7284" id="r_a9a07ba0e377d3de3df8722b5badd7284"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9a07ba0e377d3de3df8722b5badd7284"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a9a07ba0e377d3de3df8722b5badd7284">operator/</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, T const scalar)</td></tr>
<tr class="memdesc:a9a07ba0e377d3de3df8722b5badd7284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide <code>lhs</code> by <code>scalar</code>.  <br /></td></tr>
<tr class="separator:a9a07ba0e377d3de3df8722b5badd7284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4e7d8e48fc4bf3866e6ae92b036315" id="r_a5b4e7d8e48fc4bf3866e6ae92b036315"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a5b4e7d8e48fc4bf3866e6ae92b036315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a5b4e7d8e48fc4bf3866e6ae92b036315">operator/</a> (T const scalar, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a5b4e7d8e48fc4bf3866e6ae92b036315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide <code>scalar</code> by <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a5b4e7d8e48fc4bf3866e6ae92b036315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f844370bdb3924a5b4691166d3def4" id="r_a98f844370bdb3924a5b4691166d3def4"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a98f844370bdb3924a5b4691166d3def4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a98f844370bdb3924a5b4691166d3def4">operator/</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a98f844370bdb3924a5b4691166d3def4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide <code>lhs</code> by <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a98f844370bdb3924a5b4691166d3def4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb9352af7b68426cc6ca4e4f2b5e583" id="r_affb9352af7b68426cc6ca4e4f2b5e583"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:affb9352af7b68426cc6ca4e4f2b5e583"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583">dot</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:affb9352af7b68426cc6ca4e4f2b5e583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of two vectors.  <br /></td></tr>
<tr class="separator:affb9352af7b68426cc6ca4e4f2b5e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21fcab717f09c780a97270a1c8b49c" id="r_a3e21fcab717f09c780a97270a1c8b49c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a3e21fcab717f09c780a97270a1c8b49c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a3e21fcab717f09c780a97270a1c8b49c">orthogonal</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a3e21fcab717f09c780a97270a1c8b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whethor or not two vectors are orthogonal.  <br /></td></tr>
<tr class="separator:a3e21fcab717f09c780a97270a1c8b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4e3d257a2f7cc1a961d613ae161333" id="r_a2a4e3d257a2f7cc1a961d613ae161333"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a4e3d257a2f7cc1a961d613ae161333"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a2a4e3d257a2f7cc1a961d613ae161333">cross</a> (<a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;lhs, <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a2a4e3d257a2f7cc1a961d613ae161333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2D cross product of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a2a4e3d257a2f7cc1a961d613ae161333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45856a2a84c882cf7f1a74b9e850ec4" id="r_ac45856a2a84c882cf7f1a74b9e850ec4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac45856a2a84c882cf7f1a74b9e850ec4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#ac45856a2a84c882cf7f1a74b9e850ec4">cross</a> (<a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;lhs, <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ac45856a2a84c882cf7f1a74b9e850ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D cross product of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:ac45856a2a84c882cf7f1a74b9e850ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d9e43eb556d940a4473faf756b0772" id="r_a73d9e43eb556d940a4473faf756b0772"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73d9e43eb556d940a4473faf756b0772"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a73d9e43eb556d940a4473faf756b0772">orientation</a> (<a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;p, <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;q, <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="memdesc:a73d9e43eb556d940a4473faf756b0772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the orientation of <code>p</code>, <code>q</code>, and <code>r</code>.  <br /></td></tr>
<tr class="separator:a73d9e43eb556d940a4473faf756b0772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4452a273cef1ac6cbd05ccd4dfa62f9c" id="r_a4452a273cef1ac6cbd05ccd4dfa62f9c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4452a273cef1ac6cbd05ccd4dfa62f9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a4452a273cef1ac6cbd05ccd4dfa62f9c">hadamard</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a4452a273cef1ac6cbd05ccd4dfa62f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hadamard product of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a4452a273cef1ac6cbd05ccd4dfa62f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d00ddbf91208dbfc2dc119e09292c" id="r_aec8d00ddbf91208dbfc2dc119e09292c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aec8d00ddbf91208dbfc2dc119e09292c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#aec8d00ddbf91208dbfc2dc119e09292c">operator*</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aec8d00ddbf91208dbfc2dc119e09292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hadamard product of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:aec8d00ddbf91208dbfc2dc119e09292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1665dfc37e040ab0b3d8abc6b56e4" id="r_a69f1665dfc37e040ab0b3d8abc6b56e4"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a69f1665dfc37e040ab0b3d8abc6b56e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a69f1665dfc37e040ab0b3d8abc6b56e4">prefix</a> (<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a69f1665dfc37e040ab0b3d8abc6b56e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the prefix of a vector.  <br /></td></tr>
<tr class="separator:a69f1665dfc37e040ab0b3d8abc6b56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cb267b457729e9ba9c578578bd1396" id="r_a58cb267b457729e9ba9c578578bd1396"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a58cb267b457729e9ba9c578578bd1396"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestf_1_1math.html#a58cb267b457729e9ba9c578578bd1396">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a58cb267b457729e9ba9c578578bd1396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the vector <code>rhs</code> to the std::ostream <code>s</code>.  <br /></td></tr>
<tr class="separator:a58cb267b457729e9ba9c578578bd1396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for mathematical functionality. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7d8db87f09533563fde95c24959b9386" name="a7d8db87f09533563fde95c24959b9386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8db87f09533563fde95c24959b9386">&#9670;&#160;</a></span>basis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">stf::math::basis</a> = typedef std::array&lt;<a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt;T, N&gt;, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the basis of the box. </p>
<dl class="section note"><dt>Note</dt><dd>The basis is assumed to be orthonormal</dd></dl>
<p>Type alias for a basis of R^n </p><dl class="section note"><dt>Note</dt><dd>No verification is performed </dd></dl>

</div>
</div>
<a id="a7972d24df5abb4b0ad2c8231b49856f4" name="a7972d24df5abb4b0ad2c8231b49856f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7972d24df5abb4b0ad2c8231b49856f4">&#9670;&#160;</a></span>mtx2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a7972d24df5abb4b0ad2c8231b49856f4">stf::math::mtx2</a> = typedef <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 2x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1267ff0a221dc2b2930639811b5b15cb" name="a1267ff0a221dc2b2930639811b5b15cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1267ff0a221dc2b2930639811b5b15cb">&#9670;&#160;</a></span>mtx3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a1267ff0a221dc2b2930639811b5b15cb">stf::math::mtx3</a> = typedef <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 3x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ed3bcf49ecb8bec1019fe374390d9f3" name="a2ed3bcf49ecb8bec1019fe374390d9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed3bcf49ecb8bec1019fe374390d9f3">&#9670;&#160;</a></span>mtx4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">stf::math::mtx4</a> = typedef <a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt;T, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 4x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a381b50e2aee608fc1c6695bec2ce4dd6" name="a381b50e2aee608fc1c6695bec2ce4dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381b50e2aee608fc1c6695bec2ce4dd6">&#9670;&#160;</a></span>vec2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">stf::math::vec2</a> = typedef <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 2D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17d320c89555c189f20dd2991d0702f6" name="a17d320c89555c189f20dd2991d0702f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d320c89555c189f20dd2991d0702f6">&#9670;&#160;</a></span>vec3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">stf::math::vec3</a> = typedef <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 3D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab57ace2138055062fb6af63e72001eb2" name="ab57ace2138055062fb6af63e72001eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57ace2138055062fb6af63e72001eb2">&#9670;&#160;</a></span>vec4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacestf_1_1math.html#ab57ace2138055062fb6af63e72001eb2">stf::math::vec4</a> = typedef <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt;T, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 4D <a class="el" href="structstf_1_1math_1_1vec.html">vec</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2888d4e52fada9facf208ac2235b119d" name="a2888d4e52fada9facf208ac2235b119d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2888d4e52fada9facf208ac2235b119d">&#9670;&#160;</a></span>canonical_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::canonical_angle </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the equivalent angle to <code>theta</code> in [0, 2pi) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle equivalent to <code>theta</code> in [0, 2pi) </dd></dl>

</div>
</div>
<a id="aeadbd7ee49ff07cbe7ecc1f68736dda2" name="aeadbd7ee49ff07cbe7ecc1f68736dda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadbd7ee49ff07cbe7ecc1f68736dda2">&#9670;&#160;</a></span>canonical_basis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">basis</a>&lt; T, N &gt; stf::math::canonical_basis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the canonical basis for the dimension of the. </p>
<dl class="section return"><dt>Returns</dt><dd>The canonical basis of R^n </dd></dl>

</div>
</div>
<a id="a434400353fc8f81cbea4653948b7dadd" name="a434400353fc8f81cbea4653948b7dadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434400353fc8f81cbea4653948b7dadd">&#9670;&#160;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The clamped vector </dd></dl>

</div>
</div>
<a id="a7f8507043fb1a54219335dbc7fe197e3" name="a7f8507043fb1a54219335dbc7fe197e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8507043fb1a54219335dbc7fe197e3">&#9670;&#160;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The clamped vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7f8507043fb1a54219335dbc7fe197e3_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7f8507043fb1a54219335dbc7fe197e3_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7f8507043fb1a54219335dbc7fe197e3_cgraph" id="anamespacestf_1_1math_a7f8507043fb1a54219335dbc7fe197e3_cgraph">
<area shape="rect" title="Clamp a vector." alt="" coords="5,5,133,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a434400353fc8f81cbea4653948b7dadd" title="Clamp a vector." alt="" coords="181,5,309,31"/>
<area shape="poly" title=" " alt="" coords="134,15,168,15,168,21,134,21"/>
</map>
</div>

</div>
</div>
<a id="a474ddf09b4433b212a9cd307c3e54f65" name="a474ddf09b4433b212a9cd307c3e54f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ddf09b4433b212a9cd307c3e54f65">&#9670;&#160;</a></span>clamp_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::clamp_time </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp the input time to [0, 1]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input clamped to [0, 1] </dd></dl>

</div>
</div>
<a id="a66769992feb7b50f12976d9ebcc16580" name="a66769992feb7b50f12976d9ebcc16580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66769992feb7b50f12976d9ebcc16580">&#9670;&#160;</a></span>closest_equiv_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::closest_equiv_angle </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Of all angles that are equivalent to <code>phi</code>, compute the one closest to <code>theta</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest equivant angle of <code>phi</code> to <code>theta</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a66769992feb7b50f12976d9ebcc16580_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a66769992feb7b50f12976d9ebcc16580_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a66769992feb7b50f12976d9ebcc16580_cgraph" id="anamespacestf_1_1math_a66769992feb7b50f12976d9ebcc16580_cgraph">
<area shape="rect" title="Of all angles that are equivalent to phi, compute the one closest to theta." alt="" coords="5,5,225,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a2888d4e52fada9facf208ac2235b119d" title="Compute the equivalent angle to theta in [0, 2pi)" alt="" coords="273,5,467,31"/>
<area shape="poly" title=" " alt="" coords="225,15,259,15,259,21,225,21"/>
</map>
</div>

</div>
</div>
<a id="a1f25def3b146b03aee8ca35a9cb00e0e" name="a1f25def3b146b03aee8ca35a9cb00e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f25def3b146b03aee8ca35a9cb00e0e">&#9670;&#160;</a></span>counterclockwise_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::counterclockwise_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the counterclockwise angle from <code>u</code> to <code>v</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counterclockwise angle from <code>u</code> to <code>v</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a1f25def3b146b03aee8ca35a9cb00e0e_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a1f25def3b146b03aee8ca35a9cb00e0e_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a1f25def3b146b03aee8ca35a9cb00e0e_cgraph" id="anamespacestf_1_1math_a1f25def3b146b03aee8ca35a9cb00e0e_cgraph">
<area shape="rect" title="Compute the counterclockwise angle from u to v." alt="" coords="5,55,249,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a2888d4e52fada9facf208ac2235b119d" title="Compute the equivalent angle to theta in [0, 2pi)" alt="" coords="297,5,491,31"/>
<area shape="poly" title=" " alt="" coords="196,52,311,31,312,36,197,57"/>
<area shape="rect" href="namespacestf_1_1math.html#a2a4e3d257a2f7cc1a961d613ae161333" title="Compute the 2D cross product of lhs and rhs." alt="" coords="333,55,455,80"/>
<area shape="poly" title=" " alt="" coords="249,65,319,65,319,70,249,70"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="339,104,449,129"/>
<area shape="poly" title=" " alt="" coords="197,77,326,102,325,107,196,83"/>
</map>
</div>

</div>
</div>
<a id="a2a4e3d257a2f7cc1a961d613ae161333" name="a2a4e3d257a2f7cc1a961d613ae161333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4e3d257a2f7cc1a961d613ae161333">&#9670;&#160;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2D cross product of <code>lhs</code> and <code>rhs</code>. </p>
<p>This is not truely a 2D cross product. It is the cross product of the corresponding 3D vectors with 0 in the z coordinate.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 2D cross product of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ac45856a2a84c882cf7f1a74b9e850ec4" name="ac45856a2a84c882cf7f1a74b9e850ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45856a2a84c882cf7f1a74b9e850ec4">&#9670;&#160;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; stf::math::cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 3D cross product of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3D cross product of <code>lhs</code> and <code>rhs</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_ac45856a2a84c882cf7f1a74b9e850ec4_cgraph.png" border="0" usemap="#anamespacestf_1_1math_ac45856a2a84c882cf7f1a74b9e850ec4_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_ac45856a2a84c882cf7f1a74b9e850ec4_cgraph" id="anamespacestf_1_1math_ac45856a2a84c882cf7f1a74b9e850ec4_cgraph">
<area shape="rect" title="Compute the 3D cross product of lhs and rhs." alt="" coords="5,5,128,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a2a4e3d257a2f7cc1a961d613ae161333" title="Compute the 2D cross product of lhs and rhs." alt="" coords="176,5,299,31"/>
<area shape="poly" title=" " alt="" coords="128,15,162,15,162,21,128,21"/>
</map>
</div>

</div>
</div>
<a id="a0f0b0486cc93b9945e1c443fe33ed8c1" name="a0f0b0486cc93b9945e1c443fe33ed8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0b0486cc93b9945e1c443fe33ed8c1">&#9670;&#160;</a></span>cubic_bezier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::cubic_bezier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate between the four vector anchors via a cubic bezier curve. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a0f0b0486cc93b9945e1c443fe33ed8c1_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a0f0b0486cc93b9945e1c443fe33ed8c1_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a0f0b0486cc93b9945e1c443fe33ed8c1_cgraph" id="anamespacestf_1_1math_a0f0b0486cc93b9945e1c443fe33ed8c1_cgraph">
<area shape="rect" title="Interpolate between the four vector anchors via a cubic bezier curve." alt="" coords="5,31,175,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a6849132b25c2ba3d20162b29baf00b74" title="Interpolate between the four scalar anchors via a cubic bezier curve." alt="" coords="223,31,392,56"/>
<area shape="poly" title=" " alt="" coords="175,41,209,41,209,46,175,46"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="440,31,553,56"/>
<area shape="poly" title=" " alt="" coords="392,41,426,41,426,46,392,46"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="601,5,719,31"/>
<area shape="poly" title=" " alt="" coords="553,32,587,27,588,32,554,37"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="602,55,718,80"/>
<area shape="poly" title=" " alt="" coords="554,49,589,54,588,59,553,54"/>
</map>
</div>

</div>
</div>
<a id="a6849132b25c2ba3d20162b29baf00b74" name="a6849132b25c2ba3d20162b29baf00b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849132b25c2ba3d20162b29baf00b74">&#9670;&#160;</a></span>cubic_bezier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::cubic_bezier </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate between the four scalar anchors via a cubic bezier curve. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a6849132b25c2ba3d20162b29baf00b74_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a6849132b25c2ba3d20162b29baf00b74_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a6849132b25c2ba3d20162b29baf00b74_cgraph" id="anamespacestf_1_1math_a6849132b25c2ba3d20162b29baf00b74_cgraph">
<area shape="rect" title="Interpolate between the four scalar anchors via a cubic bezier curve." alt="" coords="5,31,175,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="223,31,336,56"/>
<area shape="poly" title=" " alt="" coords="175,41,209,41,209,46,175,46"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="384,5,501,31"/>
<area shape="poly" title=" " alt="" coords="336,32,370,27,370,32,337,37"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="385,55,501,80"/>
<area shape="poly" title=" " alt="" coords="337,49,372,54,371,59,336,54"/>
</map>
</div>

</div>
</div>
<a id="a14d627aaad69305e68a9afe0bcb1a15f" name="a14d627aaad69305e68a9afe0bcb1a15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d627aaad69305e68a9afe0bcb1a15f">&#9670;&#160;</a></span>cubic_hermite_spline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::cubic_hermite_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate between vectors using cubic hermite splines. </p>
<p>The spline function f(t) is defined on [0, 1] and satisfies the following constraints</p><ul>
<li>f(0) = p0</li>
<li>f(1) = p1</li>
<li>f'(0) = m0</li>
<li>f'(1) = m1</li>
</ul>
<p>This can be leveraged so that consecutive splines are C^1 at the boundary of interpolation intervals</p>
<p>reference: <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">https://en.wikipedia.org/wiki/Cubic_Hermite_spline</a></p>
<dl class="section note"><dt>Note</dt><dd>Because this function assumes a domain of [0, 1], the derivatives <code>m0</code> and <code>m1</code> must be scaled by the length of the actual interval between anchor points</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>Anchor value at the beginning of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m0</td><td>Derivative at the beginning of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>Anchor value at the end of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>Derivative at the end of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Time in [0, 1] used for interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a14d627aaad69305e68a9afe0bcb1a15f_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a14d627aaad69305e68a9afe0bcb1a15f_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a14d627aaad69305e68a9afe0bcb1a15f_cgraph" id="anamespacestf_1_1math_a14d627aaad69305e68a9afe0bcb1a15f_cgraph">
<area shape="rect" title="Interpolate between vectors using cubic hermite splines." alt="" coords="5,5,232,31"/>
<area shape="rect" href="namespacestf_1_1math.html#ad7c918df85e92af354a00b828bb12e26" title="Interpolate between scalars using cubic hermite splines." alt="" coords="280,5,507,31"/>
<area shape="poly" title=" " alt="" coords="232,15,266,15,266,21,232,21"/>
</map>
</div>

</div>
</div>
<a id="ad7c918df85e92af354a00b828bb12e26" name="ad7c918df85e92af354a00b828bb12e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c918df85e92af354a00b828bb12e26">&#9670;&#160;</a></span>cubic_hermite_spline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::cubic_hermite_spline </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate between scalars using cubic hermite splines. </p>
<p>The spline function f(t) is defined on [0, 1] and satisfies the following constraints</p><ul>
<li>f(0) = p0</li>
<li>f(1) = p1</li>
<li>f'(0) = m0</li>
<li>f'(1) = m1</li>
</ul>
<p>This can be leveraged so that consecutive splines are C^1 at the boundary of interpolation intervals</p>
<p>reference: <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">https://en.wikipedia.org/wiki/Cubic_Hermite_spline</a></p>
<dl class="section note"><dt>Note</dt><dd>Because this function assumes a domain of [0, 1], the derivatives <code>m0</code> and <code>m1</code> must be scaled by the length of the actual interval between anchor points</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>Anchor value at the beginning of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m0</td><td>Derivative at the beginning of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>Anchor value at the end of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>Derivative at the end of the interpolation interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Time in [0, 1] used for interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>

</div>
</div>
<a id="a0cbb8839da3544d5ca8a34863bdc8250" name="a0cbb8839da3544d5ca8a34863bdc8250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbb8839da3544d5ca8a34863bdc8250">&#9670;&#160;</a></span>dist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::dist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the distance between <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ad82b998efe770c215834daefd24494d9" name="ad82b998efe770c215834daefd24494d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82b998efe770c215834daefd24494d9">&#9670;&#160;</a></span>dist_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::dist_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of the distance between <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of the distance between <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="affb9352af7b68426cc6ca4e4f2b5e583" name="affb9352af7b68426cc6ca4e4f2b5e583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb9352af7b68426cc6ca4e4f2b5e583">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product of two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a8456a9732b6af9e5b7d05675efabf42a" name="a8456a9732b6af9e5b7d05675efabf42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8456a9732b6af9e5b7d05675efabf42a">&#9670;&#160;</a></span>equ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::equ </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether two scalars are less than or equal to <code>eps</code> apart. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are less than or equal to <code>eps</code> apart </dd></dl>

</div>
</div>
<a id="ab1a165fa37e0a48b01bf684ff5b9841b" name="ab1a165fa37e0a48b01bf684ff5b9841b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a165fa37e0a48b01bf684ff5b9841b">&#9670;&#160;</a></span>equ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::equ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether the distance between <code>lhs</code> and <code>rhs</code> is less than or equal to <code>eps</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>The epsilon distance to use when computating approximate equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are closer than <code>eps</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_ab1a165fa37e0a48b01bf684ff5b9841b_cgraph.png" border="0" usemap="#anamespacestf_1_1math_ab1a165fa37e0a48b01bf684ff5b9841b_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_ab1a165fa37e0a48b01bf684ff5b9841b_cgraph" id="anamespacestf_1_1math_ab1a165fa37e0a48b01bf684ff5b9841b_cgraph">
<area shape="rect" title="Compute whether the distance between lhs and rhs is less than or equal to eps." alt="" coords="5,5,117,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a0cbb8839da3544d5ca8a34863bdc8250" title="Compute the distance between lhs and rhs." alt="" coords="165,5,277,31"/>
<area shape="poly" title=" " alt="" coords="118,15,152,15,152,21,118,21"/>
</map>
</div>

</div>
</div>
<a id="a4452a273cef1ac6cbd05ccd4dfa62f9c" name="a4452a273cef1ac6cbd05ccd4dfa62f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4452a273cef1ac6cbd05ccd4dfa62f9c">&#9670;&#160;</a></span>hadamard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::hadamard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hadamard product of <code>lhs</code> and <code>rhs</code>. </p>
<p>The hadamard product is element-wise multiplication of vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hadamard product of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="acc59c171c2d2950a06a0f4efaa257027" name="acc59c171c2d2950a06a0f4efaa257027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc59c171c2d2950a06a0f4efaa257027">&#9670;&#160;</a></span>lerp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolate vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_acc59c171c2d2950a06a0f4efaa257027_cgraph.png" border="0" usemap="#anamespacestf_1_1math_acc59c171c2d2950a06a0f4efaa257027_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_acc59c171c2d2950a06a0f4efaa257027_cgraph" id="anamespacestf_1_1math_acc59c171c2d2950a06a0f4efaa257027_cgraph">
<area shape="rect" title="Linearly interpolate vectors." alt="" coords="5,31,119,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="167,31,280,56"/>
<area shape="poly" title=" " alt="" coords="119,41,153,41,153,46,119,46"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="328,5,445,31"/>
<area shape="poly" title=" " alt="" coords="280,32,314,27,314,32,281,37"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="329,55,445,80"/>
<area shape="poly" title=" " alt="" coords="281,49,316,54,315,59,280,54"/>
</map>
</div>

</div>
</div>
<a id="a72fa8ca1fb0d9248d11f7c51f93a0343" name="a72fa8ca1fb0d9248d11f7c51f93a0343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fa8ca1fb0d9248d11f7c51f93a0343">&#9670;&#160;</a></span>lerp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::lerp </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolate scalars. </p>
<dl class="section note"><dt>Note</dt><dd><code>t</code> is not clamped to [0, 1] (use <a class="el" href="namespacestf_1_1math.html#a05eb9c110c1fbb96aa868a4815a07326">lerpstep</a> if that is desired) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a72fa8ca1fb0d9248d11f7c51f93a0343_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a72fa8ca1fb0d9248d11f7c51f93a0343_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a72fa8ca1fb0d9248d11f7c51f93a0343_cgraph" id="anamespacestf_1_1math_a72fa8ca1fb0d9248d11f7c51f93a0343_cgraph">
<area shape="rect" title="Linearly interpolate scalars." alt="" coords="5,31,119,56"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="167,5,284,31"/>
<area shape="poly" title=" " alt="" coords="119,32,152,27,153,32,119,37"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="167,55,283,80"/>
<area shape="poly" title=" " alt="" coords="119,49,154,54,153,59,119,54"/>
</map>
</div>

</div>
</div>
<a id="a350ee3c7dd0cd862d7ad1dce52cec068" name="a350ee3c7dd0cd862d7ad1dce52cec068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350ee3c7dd0cd862d7ad1dce52cec068">&#9670;&#160;</a></span>lerp_inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::lerp_inv </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse of <a class="el" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343">lerp</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of <a class="el" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343">lerp</a> </dd></dl>

</div>
</div>
<a id="acbae5e01d51e37ee6de1d186e5548264" name="acbae5e01d51e37ee6de1d186e5548264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbae5e01d51e37ee6de1d186e5548264">&#9670;&#160;</a></span>lerpstep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::lerpstep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolate vectors (clamped to the endpoint values) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_acbae5e01d51e37ee6de1d186e5548264_cgraph.png" border="0" usemap="#anamespacestf_1_1math_acbae5e01d51e37ee6de1d186e5548264_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_acbae5e01d51e37ee6de1d186e5548264_cgraph" id="anamespacestf_1_1math_acbae5e01d51e37ee6de1d186e5548264_cgraph">
<area shape="rect" title="Linearly interpolate vectors (clamped to the endpoint values)" alt="" coords="5,31,147,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65" title="Clamp the input time to [0, 1]." alt="" coords="195,5,360,31"/>
<area shape="poly" title=" " alt="" coords="146,32,181,27,181,33,147,37"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="221,55,334,80"/>
<area shape="poly" title=" " alt="" coords="147,49,207,56,207,62,146,54"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="408,29,525,55"/>
<area shape="poly" title=" " alt="" coords="334,57,394,49,395,54,335,62"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="409,79,525,104"/>
<area shape="poly" title=" " alt="" coords="335,72,395,80,394,85,334,77"/>
</map>
</div>

</div>
</div>
<a id="a05eb9c110c1fbb96aa868a4815a07326" name="a05eb9c110c1fbb96aa868a4815a07326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eb9c110c1fbb96aa868a4815a07326">&#9670;&#160;</a></span>lerpstep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::lerpstep </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolate scalars (clamped to the endpoint values) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a05eb9c110c1fbb96aa868a4815a07326_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a05eb9c110c1fbb96aa868a4815a07326_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a05eb9c110c1fbb96aa868a4815a07326_cgraph" id="anamespacestf_1_1math_a05eb9c110c1fbb96aa868a4815a07326_cgraph">
<area shape="rect" title="Linearly interpolate scalars (clamped to the endpoint values)" alt="" coords="5,31,147,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65" title="Clamp the input time to [0, 1]." alt="" coords="195,5,360,31"/>
<area shape="poly" title=" " alt="" coords="146,32,181,27,181,33,147,37"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="221,55,334,80"/>
<area shape="poly" title=" " alt="" coords="147,49,207,56,207,62,146,54"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="408,29,525,55"/>
<area shape="poly" title=" " alt="" coords="334,57,394,49,395,54,335,62"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="409,79,525,104"/>
<area shape="poly" title=" " alt="" coords="335,72,395,80,394,85,334,77"/>
</map>
</div>

</div>
</div>
<a id="aa63af2216d6187253f38288212bfe0fb" name="aa63af2216d6187253f38288212bfe0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63af2216d6187253f38288212bfe0fb">&#9670;&#160;</a></span>mad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::mad </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply and add instruction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>a</code> * <code>b</code> + <code>c</code> </dd></dl>

</div>
</div>
<a id="a9777f4cdd2384cf37748bcb11f0d1d02" name="a9777f4cdd2384cf37748bcb11f0d1d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9777f4cdd2384cf37748bcb11f0d1d02">&#9670;&#160;</a></span>neq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::neq </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether two scalars are greater than <code>eps</code> apart. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are greater than <code>eps</code> apart </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a9777f4cdd2384cf37748bcb11f0d1d02_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a9777f4cdd2384cf37748bcb11f0d1d02_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a9777f4cdd2384cf37748bcb11f0d1d02_cgraph" id="anamespacestf_1_1math_a9777f4cdd2384cf37748bcb11f0d1d02_cgraph">
<area shape="rect" title="Compute whether two scalars are greater than eps apart." alt="" coords="5,5,117,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a8456a9732b6af9e5b7d05675efabf42a" title="Compute whether two scalars are less than or equal to eps apart." alt="" coords="165,5,277,31"/>
<area shape="poly" title=" " alt="" coords="118,15,152,15,152,21,118,21"/>
</map>
</div>

</div>
</div>
<a id="a2f9ad82333f9d392826685c90ef60dc0" name="a2f9ad82333f9d392826685c90ef60dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9ad82333f9d392826685c90ef60dc0">&#9670;&#160;</a></span>neq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::neq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether the distance between <code>lhs</code> and <code>rhs</code> is strictly greater than eps. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>The epsilon distance to use when computating approximate equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are further apart than <code>eps</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a2f9ad82333f9d392826685c90ef60dc0_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a2f9ad82333f9d392826685c90ef60dc0_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a2f9ad82333f9d392826685c90ef60dc0_cgraph" id="anamespacestf_1_1math_a2f9ad82333f9d392826685c90ef60dc0_cgraph">
<area shape="rect" title="Compute whether the distance between lhs and rhs is strictly greater than eps." alt="" coords="5,5,117,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a8456a9732b6af9e5b7d05675efabf42a" title="Compute whether two scalars are less than or equal to eps apart." alt="" coords="165,5,277,31"/>
<area shape="poly" title=" " alt="" coords="118,15,152,15,152,21,118,21"/>
</map>
</div>

</div>
</div>
<a id="aebd7a6357567b213ee03181eb244008d" name="aebd7a6357567b213ee03181eb244008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd7a6357567b213ee03181eb244008d">&#9670;&#160;</a></span>nms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::nms </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate the result of multiply and subtract. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>c</code> - <code>a</code> * <code>b</code> </dd></dl>

</div>
</div>
<a id="a5f5dd0464edba36002bede9ab75a9007" name="a5f5dd0464edba36002bede9ab75a9007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5dd0464edba36002bede9ab75a9007">&#9670;&#160;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a normalized vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A normalized vector in the direction of <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a55f54de1a174b97ed2fd04fb028c7cfa" name="a55f54de1a174b97ed2fd04fb028c7cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f54de1a174b97ed2fd04fb028c7cfa">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether <code>lhs</code> is approximately not equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are approximately not equal </dd></dl>

</div>
</div>
<a id="a060fc51c289538296b2c6ed408e85561" name="a060fc51c289538296b2c6ed408e85561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060fc51c289538296b2c6ed408e85561">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether <code>lhs</code> is approximately not equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are approximately not equal </dd></dl>

</div>
</div>
<a id="a39cf9f153e5f4aab36419f0dff6418ae" name="a39cf9f153e5f4aab36419f0dff6418ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cf9f153e5f4aab36419f0dff6418ae">&#9670;&#160;</a></span>operator*() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of two matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix result of the product between <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a62f480af805f0ea755daeb6b38a02070" name="a62f480af805f0ea755daeb6b38a02070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f480af805f0ea755daeb6b38a02070">&#9670;&#160;</a></span>operator*() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of a matrix with a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix <code>lhs</code> scaled by <code>rhs</code> </dd></dl>

</div>
</div>
<a id="abbd1ad0efcc79d0924035966014cc02b" name="abbd1ad0efcc79d0924035966014cc02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd1ad0efcc79d0924035966014cc02b">&#9670;&#160;</a></span>operator*() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of a matrix with a column vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A column vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The column vector result of the product between <code>lhs</code> and <code>rhs</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_abbd1ad0efcc79d0924035966014cc02b_cgraph.png" border="0" usemap="#anamespacestf_1_1math_abbd1ad0efcc79d0924035966014cc02b_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_abbd1ad0efcc79d0924035966014cc02b_cgraph" id="anamespacestf_1_1math_abbd1ad0efcc79d0924035966014cc02b_cgraph">
<area shape="rect" title="Compute the product of a matrix with a column vector." alt="" coords="5,5,156,31"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="204,5,313,31"/>
<area shape="poly" title=" " alt="" coords="156,15,190,15,190,21,156,21"/>
</map>
</div>

</div>
</div>
<a id="a1b52c08ea5d277592d46370d75a893b2" name="a1b52c08ea5d277592d46370d75a893b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b52c08ea5d277592d46370d75a893b2">&#9670;&#160;</a></span>operator*() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of a matrix with a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix <code>rhs</code> scaled by <code>lhs</code> </dd></dl>

</div>
</div>
<a id="a76ea300f09e4777ce13929e09e41f437" name="a76ea300f09e4777ce13929e09e41f437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ea300f09e4777ce13929e09e41f437">&#9670;&#160;</a></span>operator*() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale <code>rhs</code> by by <code>scalar</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>rhs</code> scaled by <code>scalar</code> </dd></dl>

</div>
</div>
<a id="acff984cc94229e85cde5f93291f2216d" name="acff984cc94229e85cde5f93291f2216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff984cc94229e85cde5f93291f2216d">&#9670;&#160;</a></span>operator*() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of a row vector with a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A row vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rwo vector result of the product between <code>lhs</code> and <code>rhs</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_acff984cc94229e85cde5f93291f2216d_cgraph.png" border="0" usemap="#anamespacestf_1_1math_acff984cc94229e85cde5f93291f2216d_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_acff984cc94229e85cde5f93291f2216d_cgraph" id="anamespacestf_1_1math_acff984cc94229e85cde5f93291f2216d_cgraph">
<area shape="rect" title="Compute the product of a row vector with a matrix." alt="" coords="5,5,156,31"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="204,5,313,31"/>
<area shape="poly" title=" " alt="" coords="156,15,190,15,190,21,156,21"/>
</map>
</div>

</div>
</div>
<a id="abf64d4c24380f9e73c146ad14e2187f9" name="abf64d4c24380f9e73c146ad14e2187f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf64d4c24380f9e73c146ad14e2187f9">&#9670;&#160;</a></span>operator*() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale <code>lhs</code> by <code>scalar</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> scaled by <code>scalar</code> </dd></dl>

</div>
</div>
<a id="aec8d00ddbf91208dbfc2dc119e09292c" name="aec8d00ddbf91208dbfc2dc119e09292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8d00ddbf91208dbfc2dc119e09292c">&#9670;&#160;</a></span>operator*() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hadamard product of <code>lhs</code> and <code>rhs</code>. </p>
<p>The hadamard product is element-wise multiplication of vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hadamard product of <code>lhs</code> and <code>rhs</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_aec8d00ddbf91208dbfc2dc119e09292c_cgraph.png" border="0" usemap="#anamespacestf_1_1math_aec8d00ddbf91208dbfc2dc119e09292c_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_aec8d00ddbf91208dbfc2dc119e09292c_cgraph" id="anamespacestf_1_1math_aec8d00ddbf91208dbfc2dc119e09292c_cgraph">
<area shape="rect" title="Compute the hadamard product of lhs and rhs." alt="" coords="5,5,156,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a4452a273cef1ac6cbd05ccd4dfa62f9c" title="Compute the hadamard product of lhs and rhs." alt="" coords="204,5,359,31"/>
<area shape="poly" title=" " alt="" coords="156,15,191,15,191,21,156,21"/>
</map>
</div>

</div>
</div>
<a id="a0b03c736e9e3277e531edc1444394f97" name="a0b03c736e9e3277e531edc1444394f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b03c736e9e3277e531edc1444394f97">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a338018216d27c5977be3fc2547b13eae" name="a338018216d27c5977be3fc2547b13eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338018216d27c5977be3fc2547b13eae">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the negative of <code>lhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negative of <code>lhs</code> </dd></dl>

</div>
</div>
<a id="a4c9226c463ed313249dbf70933a70e2c" name="a4c9226c463ed313249dbf70933a70e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9226c463ed313249dbf70933a70e2c">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the difference of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of <code>lhs</code> and <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a5b4e7d8e48fc4bf3866e6ae92b036315" name="a5b4e7d8e48fc4bf3866e6ae92b036315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4e7d8e48fc4bf3866e6ae92b036315">&#9670;&#160;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide <code>scalar</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>scalar</code> divided by <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a9a07ba0e377d3de3df8722b5badd7284" name="a9a07ba0e377d3de3df8722b5badd7284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a07ba0e377d3de3df8722b5badd7284">&#9670;&#160;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide <code>lhs</code> by <code>scalar</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> divided by <code>scalar</code> </dd></dl>

</div>
</div>
<a id="a98f844370bdb3924a5b4691166d3def4" name="a98f844370bdb3924a5b4691166d3def4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f844370bdb3924a5b4691166d3def4">&#9670;&#160;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; stf::math::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide <code>lhs</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> divided by <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a587a0cc4102350850b1b23d37cd67a79" name="a587a0cc4102350850b1b23d37cd67a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587a0cc4102350850b1b23d37cd67a79">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; stf::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the matrix <code>rhs</code> to the std::ostream <code>s</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>s</code> </dd></dl>

</div>
</div>
<a id="a58cb267b457729e9ba9c578578bd1396" name="a58cb267b457729e9ba9c578578bd1396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cb267b457729e9ba9c578578bd1396">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; stf::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the vector <code>rhs</code> to the std::ostream <code>s</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>s</code> </dd></dl>

</div>
</div>
<a id="afcaa2d59adfc9bcc1bd31520839ef4ac" name="afcaa2d59adfc9bcc1bd31520839ef4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaa2d59adfc9bcc1bd31520839ef4ac">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether <code>lhs</code> is approximately equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are approximately equal </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_afcaa2d59adfc9bcc1bd31520839ef4ac_cgraph.png" border="0" usemap="#anamespacestf_1_1math_afcaa2d59adfc9bcc1bd31520839ef4ac_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_afcaa2d59adfc9bcc1bd31520839ef4ac_cgraph" id="anamespacestf_1_1math_afcaa2d59adfc9bcc1bd31520839ef4ac_cgraph">
<area shape="rect" title="Compute whether lhs is approximately equal to rhs (uses constants&lt;T&gt;::tol as epsilon)" alt="" coords="5,5,171,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a8456a9732b6af9e5b7d05675efabf42a" title="Compute whether two scalars are less than or equal to eps apart." alt="" coords="219,5,331,31"/>
<area shape="poly" title=" " alt="" coords="171,15,205,15,205,21,171,21"/>
</map>
</div>

</div>
</div>
<a id="a78f9c8bbaf1ecfa3bf3854b0370f9100" name="a78f9c8bbaf1ecfa3bf3854b0370f9100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f9c8bbaf1ecfa3bf3854b0370f9100">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether <code>lhs</code> is approximately equal to <code>rhs</code> (uses <a class="el" href="structstf_1_1math_1_1constants.html#a98a56b0635bd1eb4c6200d49f242f73d" title="A constant error tolerance.">constants&lt;T&gt;::tol</a> as epsilon) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are approximately equal </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a78f9c8bbaf1ecfa3bf3854b0370f9100_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a78f9c8bbaf1ecfa3bf3854b0370f9100_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a78f9c8bbaf1ecfa3bf3854b0370f9100_cgraph" id="anamespacestf_1_1math_a78f9c8bbaf1ecfa3bf3854b0370f9100_cgraph">
<area shape="rect" title="Compute whether lhs is approximately equal to rhs (uses constants&lt;T&gt;::tol as epsilon)" alt="" coords="5,5,171,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a8456a9732b6af9e5b7d05675efabf42a" title="Compute whether two scalars are less than or equal to eps apart." alt="" coords="219,5,331,31"/>
<area shape="poly" title=" " alt="" coords="171,15,205,15,205,21,171,21"/>
</map>
</div>

</div>
</div>
<a id="a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e" name="a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e">&#9670;&#160;</a></span>orbit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; stf::math::orbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>focus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Orbit <code>point</code> counterclockwise around <code>focus</code> by <code>theta</code> radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focus</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The orbited point </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e_cgraph" id="anamespacestf_1_1math_a7ddb0d26aecb3e2f0fe7b6dbf5c1a89e_cgraph">
<area shape="rect" title="Orbit point counterclockwise around focus by theta radians." alt="" coords="5,5,124,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a39fc2acde1310e70f82f9eaed0efd4be" title="Construct a matrix that rotates the plane." alt="" coords="172,5,299,31"/>
<area shape="poly" title=" " alt="" coords="124,15,158,15,158,21,124,21"/>
</map>
</div>

</div>
</div>
<a id="ad82d7ca9b879c363c96ff47bc4a75ff1" name="ad82d7ca9b879c363c96ff47bc4a75ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82d7ca9b879c363c96ff47bc4a75ff1">&#9670;&#160;</a></span>orbit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; stf::math::orbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>focus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>delta_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>delta_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Orbits <code>point</code> around <code>focus</code> by <code>delta_phi</code> and <code>delta_theta</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focus</td><td>Center point of the orbit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Direction defining what direction is to the right </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_phi</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Angles <code>delta_phi</code> and <code>delta_theta</code> are spherical coordinates measured with <code>focus</code> as the origin </dd>
<dd>
<code>right</code> must be a unit vector </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The orbited point </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_ad82d7ca9b879c363c96ff47bc4a75ff1_cgraph.png" border="0" usemap="#anamespacestf_1_1math_ad82d7ca9b879c363c96ff47bc4a75ff1_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_ad82d7ca9b879c363c96ff47bc4a75ff1_cgraph" id="anamespacestf_1_1math_ad82d7ca9b879c363c96ff47bc4a75ff1_cgraph">
<area shape="rect" title="Orbits point around focus by delta_phi and delta_theta." alt="" coords="5,5,124,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a39fc2acde1310e70f82f9eaed0efd4be" title="Construct a matrix that rotates the plane." alt="" coords="172,5,299,31"/>
<area shape="poly" title=" " alt="" coords="124,15,158,15,158,21,124,21"/>
</map>
</div>

</div>
</div>
<a id="a5da3ef5bf72ec943c212645e65bc7bc8" name="a5da3ef5bf72ec943c212645e65bc7bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da3ef5bf72ec943c212645e65bc7bc8">&#9670;&#160;</a></span>orbit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::orbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>focus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>delta_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>delta_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a matrix that orbits 3-space around <code>focus</code> by <code>delta_phi</code> and <code>delta_theta</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">focus</td><td>Center point of the orbit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Direction defining what direction is to the right </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_phi</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Angles <code>delta_phi</code> and <code>delta_theta</code> are spherical coordinates measured with <code>focus</code> as the origin </dd>
<dd>
<code>right</code> must be a unit vector </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a5da3ef5bf72ec943c212645e65bc7bc8_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a5da3ef5bf72ec943c212645e65bc7bc8_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a5da3ef5bf72ec943c212645e65bc7bc8_cgraph" id="anamespacestf_1_1math_a5da3ef5bf72ec943c212645e65bc7bc8_cgraph">
<area shape="rect" title="Compute a matrix that orbits 3&#45;space around focus by delta_phi and delta_theta." alt="" coords="5,55,124,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a39fc2acde1310e70f82f9eaed0efd4be" title="Construct a matrix that rotates the plane." alt="" coords="182,5,309,31"/>
<area shape="poly" title=" " alt="" coords="111,52,183,32,185,37,113,57"/>
<area shape="rect" href="namespacestf_1_1math.html#af4d854bb00563557b5ade45a95f671c2" title="Construct a matrix that translates in x, y, and z." alt="" coords="172,55,319,80"/>
<area shape="poly" title=" " alt="" coords="124,65,158,65,158,70,124,70"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="367,80,547,105"/>
<area shape="poly" title=" " alt="" coords="113,77,172,89,265,95,353,95,353,100,265,100,172,94,112,83"/>
<area shape="poly" title=" " alt="" coords="319,73,353,78,353,83,319,79"/>
</map>
</div>

</div>
</div>
<a id="a73d9e43eb556d940a4473faf756b0772" name="a73d9e43eb556d940a4473faf756b0772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d9e43eb556d940a4473faf756b0772">&#9670;&#160;</a></span>orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::orientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the orientation of <code>p</code>, <code>q</code>, and <code>r</code>. </p>
<p>The orientation is determined based on the sign of the return value</p><ul>
<li>+ =&gt; counterclockwise</li>
<li>0 =&gt; colinear</li>
<li>- =&gt; clockwise</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The orientation of <code>p</code>, <code>q</code>, and <code>r</code> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a73d9e43eb556d940a4473faf756b0772_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a73d9e43eb556d940a4473faf756b0772_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a73d9e43eb556d940a4473faf756b0772_cgraph" id="anamespacestf_1_1math_a73d9e43eb556d940a4473faf756b0772_cgraph">
<area shape="rect" title="Compute the orientation of p, q, and r." alt="" coords="5,5,164,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a2a4e3d257a2f7cc1a961d613ae161333" title="Compute the 2D cross product of lhs and rhs." alt="" coords="212,5,335,31"/>
<area shape="poly" title=" " alt="" coords="164,15,198,15,198,21,164,21"/>
</map>
</div>

</div>
</div>
<a id="a3e21fcab717f09c780a97270a1c8b49c" name="a3e21fcab717f09c780a97270a1c8b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e21fcab717f09c780a97270a1c8b49c">&#9670;&#160;</a></span>orthogonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::math::orthogonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whethor or not two vectors are orthogonal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>lhs</code> and <code>rhs</code> are orthogonal </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a3e21fcab717f09c780a97270a1c8b49c_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a3e21fcab717f09c780a97270a1c8b49c_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a3e21fcab717f09c780a97270a1c8b49c_cgraph" id="anamespacestf_1_1math_a3e21fcab717f09c780a97270a1c8b49c_cgraph">
<area shape="rect" title="Compute whethor or not two vectors are orthogonal." alt="" coords="5,5,164,31"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="212,5,321,31"/>
<area shape="poly" title=" " alt="" coords="164,15,198,15,198,21,164,21"/>
</map>
</div>

</div>
</div>
<a id="a7cb871750293406b66f28588585cd19d" name="a7cb871750293406b66f28588585cd19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb871750293406b66f28588585cd19d">&#9670;&#160;</a></span>orthographic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::orthographic </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that computes an orthographic projection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Left plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Right plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Bottom plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Top plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Near plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Far plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7cb871750293406b66f28588585cd19d_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7cb871750293406b66f28588585cd19d_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7cb871750293406b66f28588585cd19d_cgraph" id="anamespacestf_1_1math_a7cb871750293406b66f28588585cd19d_cgraph">
<area shape="rect" title="Construct a matrix that computes an orthographic projection." alt="" coords="5,31,176,56"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a33ec84ea69fa23b489ea249793317db8" title="Compute a scale matrix." alt="" coords="236,5,392,31"/>
<area shape="poly" title=" " alt="" coords="176,31,222,26,223,31,176,36"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="224,55,404,80"/>
<area shape="poly" title=" " alt="" coords="176,50,211,54,210,59,176,55"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a3af7d18a0bfae3637174b8dd9ece2893" title="Default constructor  intializes to the identity matrix." alt="" coords="452,5,600,31"/>
<area shape="poly" title=" " alt="" coords="392,15,438,15,438,21,392,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a1369a61fa33ee78d9075bc5fc75c839b" title="Set a matrix to the identity matrix." alt="" coords="648,5,819,31"/>
<area shape="poly" title=" " alt="" coords="600,15,634,15,634,21,600,21"/>
</map>
</div>

</div>
</div>
<a id="af2dff4c8f71f49ac7c84da50160f40bf" name="af2dff4c8f71f49ac7c84da50160f40bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dff4c8f71f49ac7c84da50160f40bf">&#9670;&#160;</a></span>perspective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::perspective </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>fov_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>near_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>far_plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that computes a perspective projection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fov_y</td><td>Field of view in the y axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Aspect ratio (width/height = x/y) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">near_plane</td><td>Near plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">far_plane</td><td>Far plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection matrix </dd></dl>

</div>
</div>
<a id="a69f1665dfc37e040ab0b3d8abc6b56e4" name="a69f1665dfc37e040ab0b3d8abc6b56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1665dfc37e040ab0b3d8abc6b56e4">&#9670;&#160;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N - 1 &gt; stf::math::prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the prefix of a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prefix of <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ad265d68afa219be711bd357931cbcdbe" name="ad265d68afa219be711bd357931cbcdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad265d68afa219be711bd357931cbcdbe">&#9670;&#160;</a></span>rotate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; stf::math::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">math::vec2</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a <code>point</code> counterclockwise around the origin by <code>theta</code> radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated point </dd></dl>

</div>
</div>
<a id="a2356bb1c31343cbaf5e21cae3467c702" name="a2356bb1c31343cbaf5e21cae3467c702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2356bb1c31343cbaf5e21cae3467c702">&#9670;&#160;</a></span>rotate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; stf::math::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate <code>point</code> about <code>axis</code> by <code>theta</code> radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>axis</code> must be a unit vector </dd>
<dd>
Rotates in the direction of the right-hand rule </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated point </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a2356bb1c31343cbaf5e21cae3467c702_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a2356bb1c31343cbaf5e21cae3467c702_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a2356bb1c31343cbaf5e21cae3467c702_cgraph" id="anamespacestf_1_1math_a2356bb1c31343cbaf5e21cae3467c702_cgraph">
<area shape="rect" title="Rotate point about axis by theta radians." alt="" coords="5,31,132,56"/>
<area shape="rect" href="namespacestf_1_1math.html#a2a4e3d257a2f7cc1a961d613ae161333" title="Compute the 2D cross product of lhs and rhs." alt="" coords="180,5,303,31"/>
<area shape="poly" title=" " alt="" coords="132,31,166,26,167,32,133,37"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="187,55,296,80"/>
<area shape="poly" title=" " alt="" coords="133,49,174,55,173,61,132,55"/>
</map>
</div>

</div>
</div>
<a id="a39fc2acde1310e70f82f9eaed0efd4be" name="a39fc2acde1310e70f82f9eaed0efd4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fc2acde1310e70f82f9eaed0efd4be">&#9670;&#160;</a></span>rotate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, 2 &gt; stf::math::rotate </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that rotates the plane. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>

</div>
</div>
<a id="aea46e60693618742f4f30609517dd6a6" name="aea46e60693618742f4f30609517dd6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea46e60693618742f4f30609517dd6a6">&#9670;&#160;</a></span>rotate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a matrix that rotates 3-space around <code>axis</code> by <code>theta</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Unit vector defining the axis of rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>axis</code> must be a unit vector </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_aea46e60693618742f4f30609517dd6a6_cgraph.png" border="0" usemap="#anamespacestf_1_1math_aea46e60693618742f4f30609517dd6a6_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_aea46e60693618742f4f30609517dd6a6_cgraph" id="anamespacestf_1_1math_aea46e60693618742f4f30609517dd6a6_cgraph">
<area shape="rect" title="Compute a matrix that rotates 3&#45;space around axis by theta." alt="" coords="5,5,132,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="180,5,327,31"/>
<area shape="poly" title=" " alt="" coords="132,15,166,15,166,21,132,21"/>
</map>
</div>

</div>
</div>
<a id="a737334e3c401872dbba6373d5129e37a" name="a737334e3c401872dbba6373d5129e37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737334e3c401872dbba6373d5129e37a">&#9670;&#160;</a></span>rotate_x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_x </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that rotates about the x-axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a737334e3c401872dbba6373d5129e37a_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a737334e3c401872dbba6373d5129e37a_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a737334e3c401872dbba6373d5129e37a_cgraph" id="anamespacestf_1_1math_a737334e3c401872dbba6373d5129e37a_cgraph">
<area shape="rect" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="5,5,148,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="196,5,343,31"/>
<area shape="poly" title=" " alt="" coords="148,15,182,15,182,21,148,21"/>
</map>
</div>

</div>
</div>
<a id="a7ee4048611ec798c4c6401c07f7c50ea" name="a7ee4048611ec798c4c6401c07f7c50ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee4048611ec798c4c6401c07f7c50ea">&#9670;&#160;</a></span>rotate_xyz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_xyz </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about x -&gt; y -&gt; z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7ee4048611ec798c4c6401c07f7c50ea_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7ee4048611ec798c4c6401c07f7c50ea_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7ee4048611ec798c4c6401c07f7c50ea_cgraph" id="anamespacestf_1_1math_a7ee4048611ec798c4c6401c07f7c50ea_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about x &#45;&gt; y &#45;&gt; z." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="a7f9215b95071d6d7d2d4c4b22eab3f2e" name="a7f9215b95071d6d7d2d4c4b22eab3f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9215b95071d6d7d2d4c4b22eab3f2e">&#9670;&#160;</a></span>rotate_xzy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_xzy </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about x -&gt; z -&gt; y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7f9215b95071d6d7d2d4c4b22eab3f2e_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7f9215b95071d6d7d2d4c4b22eab3f2e_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7f9215b95071d6d7d2d4c4b22eab3f2e_cgraph" id="anamespacestf_1_1math_a7f9215b95071d6d7d2d4c4b22eab3f2e_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about x &#45;&gt; z &#45;&gt; y." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="afad16652641fafa59b53ca322306033a" name="afad16652641fafa59b53ca322306033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad16652641fafa59b53ca322306033a">&#9670;&#160;</a></span>rotate_y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_y </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that rotates about the y-axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_afad16652641fafa59b53ca322306033a_cgraph.png" border="0" usemap="#anamespacestf_1_1math_afad16652641fafa59b53ca322306033a_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_afad16652641fafa59b53ca322306033a_cgraph" id="anamespacestf_1_1math_afad16652641fafa59b53ca322306033a_cgraph">
<area shape="rect" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="5,5,148,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="196,5,343,31"/>
<area shape="poly" title=" " alt="" coords="148,15,182,15,182,21,148,21"/>
</map>
</div>

</div>
</div>
<a id="a7dca47ef149554a8c019d9f933293fb5" name="a7dca47ef149554a8c019d9f933293fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dca47ef149554a8c019d9f933293fb5">&#9670;&#160;</a></span>rotate_yxz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_yxz </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about y -&gt; x -&gt; z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7dca47ef149554a8c019d9f933293fb5_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7dca47ef149554a8c019d9f933293fb5_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7dca47ef149554a8c019d9f933293fb5_cgraph" id="anamespacestf_1_1math_a7dca47ef149554a8c019d9f933293fb5_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about y &#45;&gt; x &#45;&gt; z." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="a90da77373133ebf5cdfca8f10e5b8b98" name="a90da77373133ebf5cdfca8f10e5b8b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90da77373133ebf5cdfca8f10e5b8b98">&#9670;&#160;</a></span>rotate_yzx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_yzx </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about y -&gt; z -&gt; x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a90da77373133ebf5cdfca8f10e5b8b98_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a90da77373133ebf5cdfca8f10e5b8b98_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a90da77373133ebf5cdfca8f10e5b8b98_cgraph" id="anamespacestf_1_1math_a90da77373133ebf5cdfca8f10e5b8b98_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about y &#45;&gt; z &#45;&gt; x." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="a2d93411a1a0faaf2c7b8d972921fd9a1" name="a2d93411a1a0faaf2c7b8d972921fd9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d93411a1a0faaf2c7b8d972921fd9a1">&#9670;&#160;</a></span>rotate_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_z </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that rotates about the z-axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a2d93411a1a0faaf2c7b8d972921fd9a1_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a2d93411a1a0faaf2c7b8d972921fd9a1_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a2d93411a1a0faaf2c7b8d972921fd9a1_cgraph" id="anamespacestf_1_1math_a2d93411a1a0faaf2c7b8d972921fd9a1_cgraph">
<area shape="rect" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="5,5,147,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="195,5,341,31"/>
<area shape="poly" title=" " alt="" coords="147,15,180,15,180,21,147,21"/>
</map>
</div>

</div>
</div>
<a id="aaf3ff3d05c9d50e07a653639e95c3e68" name="aaf3ff3d05c9d50e07a653639e95c3e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3ff3d05c9d50e07a653639e95c3e68">&#9670;&#160;</a></span>rotate_zxy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_zxy </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about z -&gt; x -&gt; y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_aaf3ff3d05c9d50e07a653639e95c3e68_cgraph.png" border="0" usemap="#anamespacestf_1_1math_aaf3ff3d05c9d50e07a653639e95c3e68_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_aaf3ff3d05c9d50e07a653639e95c3e68_cgraph" id="anamespacestf_1_1math_aaf3ff3d05c9d50e07a653639e95c3e68_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about z &#45;&gt; x &#45;&gt; y." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="a48f2f84893853e32ac7276fa6cb5f910" name="a48f2f84893853e32ac7276fa6cb5f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f2f84893853e32ac7276fa6cb5f910">&#9670;&#160;</a></span>rotate_zyx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::rotate_zyx </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a rotation matrix from euler angles about z -&gt; y -&gt; x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number Type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a48f2f84893853e32ac7276fa6cb5f910_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a48f2f84893853e32ac7276fa6cb5f910_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a48f2f84893853e32ac7276fa6cb5f910_cgraph" id="anamespacestf_1_1math_a48f2f84893853e32ac7276fa6cb5f910_cgraph">
<area shape="rect" title="Compute a rotation matrix from euler angles about z &#45;&gt; y &#45;&gt; x." alt="" coords="5,55,163,80"/>
<area shape="rect" href="namespacestf_1_1math.html#a737334e3c401872dbba6373d5129e37a" title="Construct a matrix that rotates about the x&#45;axis." alt="" coords="211,5,353,31"/>
<area shape="poly" title=" " alt="" coords="135,52,217,31,218,37,136,57"/>
<area shape="rect" href="namespacestf_1_1math.html#afad16652641fafa59b53ca322306033a" title="Construct a matrix that rotates about the y&#45;axis." alt="" coords="211,55,353,80"/>
<area shape="poly" title=" " alt="" coords="163,65,197,65,197,70,163,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a2d93411a1a0faaf2c7b8d972921fd9a1" title="Construct a matrix that rotates about the z&#45;axis." alt="" coords="211,104,353,129"/>
<area shape="poly" title=" " alt="" coords="136,77,218,98,217,103,135,83"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a67fb547b4a002484b260779e286f88ad" title="Const access to a single row of the matrix." alt="" coords="401,55,548,80"/>
<area shape="poly" title=" " alt="" coords="333,28,412,49,410,54,332,33"/>
<area shape="poly" title=" " alt="" coords="354,65,387,65,387,70,354,70"/>
<area shape="poly" title=" " alt="" coords="332,101,410,81,412,86,333,107"/>
</map>
</div>

</div>
</div>
<a id="a612899b7860d515c5908b0410c0555ba" name="a612899b7860d515c5908b0410c0555ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612899b7860d515c5908b0410c0555ba">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scalars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that scales in x, y, and z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalars</td><td>The scalars for scaling in x, y, and z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scale matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a612899b7860d515c5908b0410c0555ba_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a612899b7860d515c5908b0410c0555ba_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a612899b7860d515c5908b0410c0555ba_cgraph" id="anamespacestf_1_1math_a612899b7860d515c5908b0410c0555ba_cgraph">
<area shape="rect" title="Construct a matrix that scales in x, y, and z." alt="" coords="5,5,128,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a33ec84ea69fa23b489ea249793317db8" title="Compute a scale matrix." alt="" coords="176,5,332,31"/>
<area shape="poly" title=" " alt="" coords="128,15,162,15,162,21,128,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a3af7d18a0bfae3637174b8dd9ece2893" title="Default constructor  intializes to the identity matrix." alt="" coords="380,5,528,31"/>
<area shape="poly" title=" " alt="" coords="332,15,366,15,366,21,332,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a1369a61fa33ee78d9075bc5fc75c839b" title="Set a matrix to the identity matrix." alt="" coords="576,5,747,31"/>
<area shape="poly" title=" " alt="" coords="528,15,562,15,562,21,528,21"/>
</map>
</div>

</div>
</div>
<a id="a6e24a954343bbe7eeeec8af9f2550cf3" name="a6e24a954343bbe7eeeec8af9f2550cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e24a954343bbe7eeeec8af9f2550cf3">&#9670;&#160;</a></span>scale_x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::scale_x </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that scales in x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scale matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a6e24a954343bbe7eeeec8af9f2550cf3_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a6e24a954343bbe7eeeec8af9f2550cf3_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a6e24a954343bbe7eeeec8af9f2550cf3_cgraph" id="anamespacestf_1_1math_a6e24a954343bbe7eeeec8af9f2550cf3_cgraph">
<area shape="rect" title="Construct a matrix that scales in x." alt="" coords="5,5,143,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a33ec84ea69fa23b489ea249793317db8" title="Compute a scale matrix." alt="" coords="191,5,347,31"/>
<area shape="poly" title=" " alt="" coords="143,15,177,15,177,21,143,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a3af7d18a0bfae3637174b8dd9ece2893" title="Default constructor  intializes to the identity matrix." alt="" coords="395,5,543,31"/>
<area shape="poly" title=" " alt="" coords="347,15,381,15,381,21,347,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a1369a61fa33ee78d9075bc5fc75c839b" title="Set a matrix to the identity matrix." alt="" coords="591,5,761,31"/>
<area shape="poly" title=" " alt="" coords="543,15,577,15,577,21,543,21"/>
</map>
</div>

</div>
</div>
<a id="a46513ba64d6968b3462b6686c11b8169" name="a46513ba64d6968b3462b6686c11b8169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46513ba64d6968b3462b6686c11b8169">&#9670;&#160;</a></span>scale_y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::scale_y </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that scales in y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scale matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a46513ba64d6968b3462b6686c11b8169_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a46513ba64d6968b3462b6686c11b8169_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a46513ba64d6968b3462b6686c11b8169_cgraph" id="anamespacestf_1_1math_a46513ba64d6968b3462b6686c11b8169_cgraph">
<area shape="rect" title="Construct a matrix that scales in y." alt="" coords="5,5,143,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a33ec84ea69fa23b489ea249793317db8" title="Compute a scale matrix." alt="" coords="191,5,347,31"/>
<area shape="poly" title=" " alt="" coords="143,15,177,15,177,21,143,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a3af7d18a0bfae3637174b8dd9ece2893" title="Default constructor  intializes to the identity matrix." alt="" coords="395,5,543,31"/>
<area shape="poly" title=" " alt="" coords="347,15,381,15,381,21,347,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a1369a61fa33ee78d9075bc5fc75c839b" title="Set a matrix to the identity matrix." alt="" coords="591,5,761,31"/>
<area shape="poly" title=" " alt="" coords="543,15,577,15,577,21,543,21"/>
</map>
</div>

</div>
</div>
<a id="a7a64817a9e20e05dbda0fc34eb46a13b" name="a7a64817a9e20e05dbda0fc34eb46a13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a64817a9e20e05dbda0fc34eb46a13b">&#9670;&#160;</a></span>scale_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::scale_z </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that scales in z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scale matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a7a64817a9e20e05dbda0fc34eb46a13b_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a7a64817a9e20e05dbda0fc34eb46a13b_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a7a64817a9e20e05dbda0fc34eb46a13b_cgraph" id="anamespacestf_1_1math_a7a64817a9e20e05dbda0fc34eb46a13b_cgraph">
<area shape="rect" title="Construct a matrix that scales in z." alt="" coords="5,5,141,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a33ec84ea69fa23b489ea249793317db8" title="Compute a scale matrix." alt="" coords="189,5,345,31"/>
<area shape="poly" title=" " alt="" coords="142,15,176,15,176,21,142,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a3af7d18a0bfae3637174b8dd9ece2893" title="Default constructor  intializes to the identity matrix." alt="" coords="393,5,541,31"/>
<area shape="poly" title=" " alt="" coords="346,15,379,15,379,21,346,21"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a1369a61fa33ee78d9075bc5fc75c839b" title="Set a matrix to the identity matrix." alt="" coords="589,5,760,31"/>
<area shape="poly" title=" " alt="" coords="541,15,576,15,576,21,541,21"/>
</map>
</div>

</div>
</div>
<a id="a8eb4a3b24b4f682a650ba5a9c1b9ad63" name="a8eb4a3b24b4f682a650ba5a9c1b9ad63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb4a3b24b4f682a650ba5a9c1b9ad63">&#9670;&#160;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::sigmoid </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sigmoid of the input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output of the sigmoid function </dd></dl>

</div>
</div>
<a id="a703701d9522bd2e4fabd778d35f103e5" name="a703701d9522bd2e4fabd778d35f103e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703701d9522bd2e4fabd778d35f103e5">&#9670;&#160;</a></span>smooth_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::smooth_time </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smooths the input time for use in smoothstep. </p>
<p>This function first clamps the input to s in [0, 1] and then returns s^2 * (3 - 2 * s)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input time smoothed close to 0 and 1 </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a703701d9522bd2e4fabd778d35f103e5_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a703701d9522bd2e4fabd778d35f103e5_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a703701d9522bd2e4fabd778d35f103e5_cgraph" id="anamespacestf_1_1math_a703701d9522bd2e4fabd778d35f103e5_cgraph">
<area shape="rect" title="Smooths the input time for use in smoothstep." alt="" coords="5,5,180,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65" title="Clamp the input time to [0, 1]." alt="" coords="228,5,393,31"/>
<area shape="poly" title=" " alt="" coords="180,15,214,15,214,21,180,21"/>
</map>
</div>

</div>
</div>
<a id="aaf6aefbf6bcff077cfb2d540bff3d65a" name="aaf6aefbf6bcff077cfb2d540bff3d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6aefbf6bcff077cfb2d540bff3d65a">&#9670;&#160;</a></span>smoothstep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; stf::math::smoothstep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">math::vec</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate smoothly between the vector endpoints. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_aaf6aefbf6bcff077cfb2d540bff3d65a_cgraph.png" border="0" usemap="#anamespacestf_1_1math_aaf6aefbf6bcff077cfb2d540bff3d65a_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_aaf6aefbf6bcff077cfb2d540bff3d65a_cgraph" id="anamespacestf_1_1math_aaf6aefbf6bcff077cfb2d540bff3d65a_cgraph">
<area shape="rect" title="Interpolate smoothly between the vector endpoints." alt="" coords="5,80,171,105"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="249,55,363,80"/>
<area shape="poly" title=" " alt="" coords="170,80,236,73,236,78,171,86"/>
<area shape="rect" href="namespacestf_1_1math.html#a703701d9522bd2e4fabd778d35f103e5" title="Smooths the input time for use in smoothstep." alt="" coords="219,104,393,129"/>
<area shape="poly" title=" " alt="" coords="171,99,205,103,205,108,170,104"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="465,5,583,31"/>
<area shape="poly" title=" " alt="" coords="362,52,453,31,454,36,363,57"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="466,55,582,80"/>
<area shape="poly" title=" " alt="" coords="363,65,452,65,452,70,363,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65" title="Clamp the input time to [0, 1]." alt="" coords="441,104,607,129"/>
<area shape="poly" title=" " alt="" coords="394,114,428,114,428,119,394,119"/>
</map>
</div>

</div>
</div>
<a id="abc8137cac1b4235e147e53d3a86180a1" name="abc8137cac1b4235e147e53d3a86180a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8137cac1b4235e147e53d3a86180a1">&#9670;&#160;</a></span>smoothstep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::smoothstep </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate smoothly between the scalar endpoints. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated scalar </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_abc8137cac1b4235e147e53d3a86180a1_cgraph.png" border="0" usemap="#anamespacestf_1_1math_abc8137cac1b4235e147e53d3a86180a1_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_abc8137cac1b4235e147e53d3a86180a1_cgraph" id="anamespacestf_1_1math_abc8137cac1b4235e147e53d3a86180a1_cgraph">
<area shape="rect" title="Interpolate smoothly between the scalar endpoints." alt="" coords="5,80,171,105"/>
<area shape="rect" href="namespacestf_1_1math.html#a72fa8ca1fb0d9248d11f7c51f93a0343" title="Linearly interpolate scalars." alt="" coords="249,55,363,80"/>
<area shape="poly" title=" " alt="" coords="170,80,236,73,236,78,171,86"/>
<area shape="rect" href="namespacestf_1_1math.html#a703701d9522bd2e4fabd778d35f103e5" title="Smooths the input time for use in smoothstep." alt="" coords="219,104,393,129"/>
<area shape="poly" title=" " alt="" coords="171,99,205,103,205,108,170,104"/>
<area shape="rect" href="namespacestf_1_1math.html#aa63af2216d6187253f38288212bfe0fb" title="Multiply and add instruction." alt="" coords="465,5,583,31"/>
<area shape="poly" title=" " alt="" coords="362,52,453,31,454,36,363,57"/>
<area shape="rect" href="namespacestf_1_1math.html#aebd7a6357567b213ee03181eb244008d" title="Negate the result of multiply and subtract." alt="" coords="466,55,582,80"/>
<area shape="poly" title=" " alt="" coords="363,65,452,65,452,70,363,70"/>
<area shape="rect" href="namespacestf_1_1math.html#a474ddf09b4433b212a9cd307c3e54f65" title="Clamp the input time to [0, 1]." alt="" coords="441,104,607,129"/>
<area shape="poly" title=" " alt="" coords="394,114,428,114,428,119,394,119"/>
</map>
</div>

</div>
</div>
<a id="a8ea43915b87ab6b1e48e0a660d99b873" name="a8ea43915b87ab6b1e48e0a660d99b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea43915b87ab6b1e48e0a660d99b873">&#9670;&#160;</a></span>to_basis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a7d8db87f09533563fde95c24959b9386">basis</a>&lt; T, N &gt; stf::math::to_basis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1mtx.html">mtx</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a rotation matrix to a basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis corresponding to <code>rotation</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>rotation</code> is assumed to be orthonormal </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a8ea43915b87ab6b1e48e0a660d99b873_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a8ea43915b87ab6b1e48e0a660d99b873_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a8ea43915b87ab6b1e48e0a660d99b873_cgraph" id="anamespacestf_1_1math_a8ea43915b87ab6b1e48e0a660d99b873_cgraph">
<area shape="rect" title="Convert a rotation matrix to a basis." alt="" coords="5,5,148,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a9634d5b1a26314750d4b68d7a5ab59fc" title="Const access to a single column of the matrix." alt="" coords="196,5,337,31"/>
<area shape="poly" title=" " alt="" coords="148,15,182,15,182,21,148,21"/>
</map>
</div>

</div>
</div>
<a id="a0db343b05b5137368f26a08ace47a94b" name="a0db343b05b5137368f26a08ace47a94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db343b05b5137368f26a08ace47a94b">&#9670;&#160;</a></span>to_degrees()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::to_degrees </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert radieans to degrees. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The andle <code>rad</code> in degrees </dd></dl>

</div>
</div>
<a id="ab20df763f820598019d628e96c1916b8" name="ab20df763f820598019d628e96c1916b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20df763f820598019d628e96c1916b8">&#9670;&#160;</a></span>to_euclidean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">math::vec3</a>&lt; T &gt; stf::math::to_euclidean </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert spherical coordinates to euclidean. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The euclidean coordinates </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_ab20df763f820598019d628e96c1916b8_cgraph.png" border="0" usemap="#anamespacestf_1_1math_ab20df763f820598019d628e96c1916b8_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_ab20df763f820598019d628e96c1916b8_cgraph" id="anamespacestf_1_1math_ab20df763f820598019d628e96c1916b8_cgraph">
<area shape="rect" title="Convert spherical coordinates to euclidean." alt="" coords="5,5,176,31"/>
<area shape="rect" href="namespacestf_1_1math.html#a731976438129a4b458e42de14270eaae" title="Compute unit vector in the direction of theta." alt="" coords="224,5,385,31"/>
<area shape="poly" title=" " alt="" coords="176,15,211,15,211,21,176,21"/>
</map>
</div>

</div>
</div>
<a id="aeb991336cd40e9b939bc08400bbd41b3" name="aeb991336cd40e9b939bc08400bbd41b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb991336cd40e9b939bc08400bbd41b3">&#9670;&#160;</a></span>to_radians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stf::math::to_radians </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle <code>deg</code> in radians </dd></dl>

</div>
</div>
<a id="af4d854bb00563557b5ade45a95f671c2" name="af4d854bb00563557b5ade45a95f671c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d854bb00563557b5ade45a95f671c2">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstf_1_1math_1_1vec.html">vec</a>&lt; T, 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scalars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that translates in x, y, and z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalars</td><td>The scalars for translating in x, y, and z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_af4d854bb00563557b5ade45a95f671c2_cgraph.png" border="0" usemap="#anamespacestf_1_1math_af4d854bb00563557b5ade45a95f671c2_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_af4d854bb00563557b5ade45a95f671c2_cgraph" id="anamespacestf_1_1math_af4d854bb00563557b5ade45a95f671c2_cgraph">
<area shape="rect" title="Construct a matrix that translates in x, y, and z." alt="" coords="5,5,152,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="200,5,380,31"/>
<area shape="poly" title=" " alt="" coords="152,15,186,15,186,21,152,21"/>
</map>
</div>

</div>
</div>
<a id="a2a864dfaf88a1974acada6da7f4f94e1" name="a2a864dfaf88a1974acada6da7f4f94e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a864dfaf88a1974acada6da7f4f94e1">&#9670;&#160;</a></span>translate_x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::translate_x </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that translates in x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a2a864dfaf88a1974acada6da7f4f94e1_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a2a864dfaf88a1974acada6da7f4f94e1_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a2a864dfaf88a1974acada6da7f4f94e1_cgraph" id="anamespacestf_1_1math_a2a864dfaf88a1974acada6da7f4f94e1_cgraph">
<area shape="rect" title="Construct a matrix that translates in x." alt="" coords="5,5,167,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="215,5,395,31"/>
<area shape="poly" title=" " alt="" coords="167,15,201,15,201,21,167,21"/>
</map>
</div>

</div>
</div>
<a id="a410b2e16574bb1b729ae2a7d1d45f614" name="a410b2e16574bb1b729ae2a7d1d45f614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410b2e16574bb1b729ae2a7d1d45f614">&#9670;&#160;</a></span>translate_y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::translate_y </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that translates in y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a410b2e16574bb1b729ae2a7d1d45f614_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a410b2e16574bb1b729ae2a7d1d45f614_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a410b2e16574bb1b729ae2a7d1d45f614_cgraph" id="anamespacestf_1_1math_a410b2e16574bb1b729ae2a7d1d45f614_cgraph">
<area shape="rect" title="Construct a matrix that translates in y." alt="" coords="5,5,167,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="215,5,395,31"/>
<area shape="poly" title=" " alt="" coords="167,15,201,15,201,21,167,21"/>
</map>
</div>

</div>
</div>
<a id="ae7655d5d1e7c17f9983c7b1b90e8ccb0" name="ae7655d5d1e7c17f9983c7b1b90e8ccb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7655d5d1e7c17f9983c7b1b90e8ccb0">&#9670;&#160;</a></span>translate_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::translate_z </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix that translates in z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_ae7655d5d1e7c17f9983c7b1b90e8ccb0_cgraph.png" border="0" usemap="#anamespacestf_1_1math_ae7655d5d1e7c17f9983c7b1b90e8ccb0_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_ae7655d5d1e7c17f9983c7b1b90e8ccb0_cgraph" id="anamespacestf_1_1math_ae7655d5d1e7c17f9983c7b1b90e8ccb0_cgraph">
<area shape="rect" title="Construct a matrix that translates in z." alt="" coords="5,5,165,31"/>
<area shape="rect" href="structstf_1_1math_1_1mtx.html#a8047848dbbccdc0834492c2bbd10328f" title="Compute a translation matrix." alt="" coords="213,5,393,31"/>
<area shape="poly" title=" " alt="" coords="166,15,200,15,200,21,166,21"/>
</map>
</div>

</div>
</div>
<a id="a731976438129a4b458e42de14270eaae" name="a731976438129a4b458e42de14270eaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731976438129a4b458e42de14270eaae">&#9670;&#160;</a></span>unit_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a381b50e2aee608fc1c6695bec2ce4dd6">vec2</a>&lt; T &gt; stf::math::unit_vector </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute unit vector in the direction of <code>theta</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>An angle measured counterclockwise from (1, 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit vector in the direction of <code>theta</code> </dd></dl>

</div>
</div>
<a id="a182c445b1dfe2d55a7761bf111fb12fb" name="a182c445b1dfe2d55a7761bf111fb12fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182c445b1dfe2d55a7761bf111fb12fb">&#9670;&#160;</a></span>unit_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; stf::math::unit_vector </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit vector defined by <code>theta</code> and <code>phi</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>An angle measured counterclockwise from (1, 0, 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi</td><td>An angle measured from (0, 0, 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit vector defined by <code>theta</code> and <code>phi</code> </dd></dl>

</div>
</div>
<a id="a3ec55e14ebb462574ee6b87b715edb28" name="a3ec55e14ebb462574ee6b87b715edb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec55e14ebb462574ee6b87b715edb28">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestf_1_1math.html#a2ed3bcf49ecb8bec1019fe374390d9f3">mtx4</a>&lt; T &gt; stf::math::view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>look</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestf_1_1math.html#a17d320c89555c189f20dd2991d0702f6">vec3</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a view matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Number type (eg float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eye</td><td>The camera eye </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">look</td><td>The look direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">up</td><td>The up direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The view matrix </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestf_1_1math_a3ec55e14ebb462574ee6b87b715edb28_cgraph.png" border="0" usemap="#anamespacestf_1_1math_a3ec55e14ebb462574ee6b87b715edb28_cgraph" alt=""/></div>
<map name="anamespacestf_1_1math_a3ec55e14ebb462574ee6b87b715edb28_cgraph" id="anamespacestf_1_1math_a3ec55e14ebb462574ee6b87b715edb28_cgraph">
<area shape="rect" title="Construct a view matrix." alt="" coords="5,5,124,31"/>
<area shape="rect" href="namespacestf_1_1math.html#affb9352af7b68426cc6ca4e4f2b5e583" title="Compute the dot product of two vectors." alt="" coords="172,5,281,31"/>
<area shape="poly" title=" " alt="" coords="124,15,158,15,158,21,124,21"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestf.html">stf</a></li><li class="navelem"><a class="el" href="namespacestf_1_1math.html">math</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
